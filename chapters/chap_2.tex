\chapter{Linear Amortized Analysis} \label{chap:linear}

Linear Amortized Analysis concerns itself with linear potentials only, that is potential functions that are linear with respect to the input parameter. As such, \(f(n) = 3 \cdot n + 2\) is considered a linear potential and \(f(n) = 3 \cdot n^{2} + 2\) is not. 
In chapter \ref{chap:polynomial-potential} we introduce automatic amortized analysis for polynomial potentials, which builds on the case for linear potentials.

\section{Type System} \label{chap:type-system}
In order to enable bounding resource consumption, we need to define a type system that permits this. More precisely, we introduce a type system featuring resource-annotated types. This is done by supplementing types with a potential \(q \in \mathbb{Q}\). 
One resource-annotated type is that of a generic list \(L^q(A)\). That is, a list comprising elements of type \(A\), where \emph{every element} of the list has the assigned potential \(q\).
We will see that this induces a potential of the form \(f(n) = q \cdot n\), where \(n\) is the size of the list. 

Another resource-annotated type are functions, written \(A \xrightarrow{p/p'} B\). The meaning of the potentials \(p\) and \(p'\) is different compared to lists. The type \(A \xrightarrow{p/p'} B\) can be interpreted as a function from type A to type B, for which we need \(p\) \emph{additional} resources in order to start the evaluation and are left with \(p'\) resources after evaluation. The resources \(p\) are \emph{additional}, as the type \emph{A} may be resource-annotated itself.

The type system used is given as an EBNF in Figure \ref{fig:type-system} below:

\begin{figure}[H]
\centering
\(A,B = Unit | A \times B | A + B | L^q(A) | A \xrightarrow{p/p'} B\)
\caption{Resource-Annotated Type System}
\label{fig:type-system}
\end{figure}
\todo{Maybe split the type system into primitive two different grammars?}

Besides the aforementioned types, pairs, denoted by \(A \times B\), and sum types, denoted by \(A + B\) are available types. Practical examples for sum types with which the reader might be familiar are, among many: union in C++ and enums in rust. 

Before introducing type rules, let us build an intuition for resource-bound types, by working through a rudimentary example. Given the function \emph{addL} in figure \ref{func:add-l} below, we want to calculate an upper bound on heap-space usage. For this, we conclude that a list storing values of a primitive type \emph{A} must allocate two memory cells. One for the value itself, and one for the pointer to the next element in the list. Furthermore, storing a list of type \emph{nil} demands no memory.
This choice is mainly for convenience, as it only alters the resulting amount of memory cells by a constant term.

Equipped with this assumption, we can immediately conclude: Given a list \emph{l} of length \(n\), the function \emph{addL} requires \(2n\) memory cells. Hence, we get \(l : L^{2}(A)\). \emph{addL} requires no additional resources, besides those supplemented by the list \emph{l}. 

Let us now incrementally build up a type for the function \emph{addL}. Because it is a function type, we can start with \(addL: A \xrightarrow{p/p'} B\). The input of \emph{addL} is of type \((int, L^{q}(A))\), a pair comprising an integer and a list. Updating our initial typing, we get \(addL : (int, L^{q}(A)) \xrightarrow{p/p'} B)\). Because \emph{addL} returns a list, we can further update the type \emph{B}, yielding \(addL: (int, L^{q}(A)) \xrightarrow{p/p'} L^{q'}(A)}\). Lastly, we need to infer the resource bounds \(p, p', q, q'\). We already inferred that \(q = 2\) and that \(p = p' = 0\). Thus, the only resource annotation missing is \(q'\). Since all the necessary resources are provided by the input list, the resource bound does not increase with respect to the output list. 

Thus, we arrive at the following type for \emph{addL}:

\[addL: (int, L^{2}(A)) \xrightarrow{0/0} L^{0}(A) \]

\begin{figure}[H]
\centering
\begin{minted}{ocaml}
fun addL i l = match l with | nil -> nil
   | x::xs -> (x + i)::(addL i xs)
end
\end{minted}
\caption{AddL function}
\label{func:add-l}
\end{figure}

In order to automize the above procedure, the rules for inference need to be rigorously defined by means of \emph{type rules}. Furthermore, we need to select a set of potential functions that are specifically handy for automatic analysis. This is the aim of 

\section{The Potential Function}
Before defining the potential function, we need to introduce a couple of definitions in order to permit a rigorous definition.
Let \(A\) be a (resource-annotated) type, denote by \(\llbracket A \rrbracket\) the set of \emph{semantic values} of type A. That is, all the concrete values that belong to type \(A\). \(\llbracket L^{q}(int)\rrbracket \), therefore, describes the set of lists of integers, and \([1;2;3] \in \llbracket L^{q}(int)\rrbracket \). 

When arguing about the potential of a variable, we need to consider the \emph{heap} and the \emph{stack}, denoted by \(H\) and \(V\) respectively. This is because the type of a variables, as well as its potential, can only be inferred if we can map the variable to a concrete value - which is precisely what the stack does. The correct notation would therefore be \(\Phi(V(x) : A)\), which is less ergonomic than writing \(\Phi(x : A)\). For convenience, we use the second notation and assume that a stack \(V\) is given implicitly.
In order to track resource-consumption, we need to supply a heap \(H\). Similarly, we assume the head as implicit and use our ergonomic notation, instead of \(\Phi_{H}(x : A)\).  
We denote the set of types with linear potential by \(\mathcal{A}_{lin}\). 

Throughout this thesis we assume that any primitive types, that is types without a resource-annotation, have no effect on the resource consumption. As such their potential is zero. 
\todo{Elaborate on why this is okay and how to move to non zero potentials}



\section{Judgements}
 In this section we will introduce all needed definitions from type theory, that will allow us to encode a notion of resource usage in type judgements.
 Let \emph{Bochum} be a string of characters. In type theory, writing \(Bochum: T\) is called a \emph{typing judgement}, stating that \emph{Bochum} is of type T. In this example \(T\) could be the type \emph{String}. However, \(Bochum : int\) would not be valid, for obvious reasons.
 
 In the above example, we were judging the concrete \emph{value}. In most cases, we dont perform judgements over concrete values, but using the variable names assigned to them; this resembles how software is written, in that we assign variable names to values.
 Because judgments usually only comprise variable names, we need to have a mechanism that allows associating variable names with values - this is precisely what \emph{contexts} do. A context \(\Gamma\) is a mapping from variable names to values. Putting both together, we can write the following judgement: \(\Gamma \vdash e: A\), which can be interpreted as ''Given the context \(\Gamma\), the expression \(e\) is of type \(A\)''.
 After introducing the Type system in \ref{chap:type-system}, we will introduce typing rules. Those will provide a mechanism of deducing new information. 
 
Whenever we make a claim about the result of some computation, there are different levels we have to discriminate.

 We call the first type of judgement a \emph{Bounding Judgement}, and encode it as \(\Gamma \sststile{p'}{p} e : A\), where \(\Gamma\) is a context, \(p\) and \(p'\) are non-negative rationals and \(e\) is some expression of type \(A\). The judgement can then be read as ''Given the context \(\Gamma\) and \(p\) resources, we can evaluate the expression \(e\) of type \(A\), and we have \(p'\) resources remaining''.
 \todo{Do these judgements have specific names???}

 The second type of judgement is an \emph{Evaluation Judgement}. While a \emph{Bounding Judgment} provides a judgement about the type of an expression along with a resource bound, an \emph{Evaluation Judgement} is an assertion about the concrete result of an expression. The prior permits eliciting resource bounds for \emph{any} expression of a specific type, whereas the latter provides concrete bounds for specific expression. 

 We denote a \emph{Bounding Judgement} by writing \(e \downarrow v\), expressing that the expression \(e\) evaluates to the value \(v\). This judgement can also be decorated with resource bounds in the following way: Denote by \(e \underset{p/p'}{\downarrow} v\) that the expression \(e\) evaluates to the value \(v\), requiring \(p\) available resources beforehand and returning \(p'\) resources after evaluation.


\subsection{Type rules}
\label{sec:type-rules}
