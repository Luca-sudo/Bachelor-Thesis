\chapter{Resources}

Throughout this thesis, we introduce programming language constructs, in order to elicit resource consumption of programs. It is, therefore, important to mention that resources can be an arbitrary cost metric, including but not limited to: memory consumption, runtime, energy consumption. While the details of the respective type of resource are nuanced, the resource consumption generally comprises two parts: Resources consumed to start evaluating, and possibly, resources freed after evaluation.

Tracing resource consumption throughout the evaluation of a program may look like this:

\ctikzfig{resource_intro}

We are most interested in the value at the beginning and at the end, which leads us to simplify the resource consumption further. Drawing a straight line between resources at the start and at the end.

\ctikzfig{resource_reduced}

We use this visual representation to foster intuition throughout this chapter - illustrating examples and concepts.

This overarching structure of resource demands leads us to a refined version of \href{def:resource-consumption}{resource consumption}. Furthermore, we will define a rich structure on the resource demand of programs; Most notably, we introduce sequencing of resource demands, which gives rise to a monoidal structure, and relaxation, which defines a \emph{partial order} - allowing us to compare resource demands, in a way that is consistent with our intuition of cost.

\section{Resource Demand}

We start by defining resources mathematically, which will lead to defining resource demand of programs as a tuple of resources. Afterward, we introduce multiplication of these tuples and disambiguate reasoning about resource demand, by naming key figures of resource demands.

\begin{definition}[Resources]\label{def:resources}
   We identify resources with the natural numbers, where the value refers to an amount of resources.
   \[
      \resource = \mathbb{N}_0
   \]
\end{definition}


\begin{definition}[Resource demand]\label{def:resource-pair}
   We denote by \(\demand\) the set of resource demands, which is a pair of resources.
   \[
      \demand = \resource \times \resource
   \]
\end{definition}

When reasoning about a resource demand \((p_0, p_1) \in \demand\), \(p_0\) are the \emph{initial} resources, and \(p_1\) are the \emph{residual} resources. 

\begin{example}
   A \nameref{def:resource-pair} with 4 initial and 2 residual resources is denoted by \((4, 2)\).
\end{example}

\ctikzfig{ex25}

It is important to distinguish the resource demand from the \emph{resource consumption}. The resource consumption of a program is precisely its residual resource subtracted from its initial resources. 

\begin{definition}[Resource Consumption]\label{def:resource-consumption}
   Given \((p_0, p_1) \in \demand\), we define the \emph{resource consumption} as the difference between initial and residual resources, \(p_0 - p_1\).
\end{definition}

We can think of the resource consumption as the directed (!) height of the associated resource diagram. Consider the following example.

\begin{example}
   For \((4, 2) \in \resource\), the resource consumption equals \(4 - 2 = 2\).
\end{example}

\ctikzfig{resource_consumption}

As most programs are made up of multiple subsequent evaluations, we need a mechanism for composing evaluations; More specifically, we need to define the resource cost of subsequent evaluations. 
For this, there are two cases: The first operation has enough residual resources for the second operation to be executed, or the second operation requires more initial resources than residual resources of the first operation provides. In the latter case we need to increase the initial resources of the composed evaluation.
left
This yields two cases for the resulting resource demand:
\[
   \begin{cases}
      (p_0 + q_0 - p_1,  q_1) & \mbox{if } q_0 \geq p_1 \\
      (p_0,q_1 + p_1 - q_0) & \mbox{if } q_0 <    p_1 
   \end{cases}
\]

We can, however, simplify the multiplication of resource demands by merging the two cases. Consider that \(p_0 - p_1 + \max(p_1, q_0)\) precisely matches the initial resources for both cases. Similarly, \(q_1 - q_0 + \max(p_1, q_0)\) precisely matches the residual resources for both cases. 
This yields the following definition:

\begin{definition}[Sequencing resource demands]
   \label{def:multiplying-pairs}
   Let \((p_0, p_1)\) and \((q_0, q_1)\) be two \nameref{def:resource-pair}s, as introduced above. We then define:
   \[(p_0, p_1) \sequence (q_0, q_1) = (p_0 - p_1 + \max(p_1, q_0), q_1 - q_0 + \max(p_1, q_0))\]
\end{definition}

\begin{example}
   For \((4, 2), (5,0) \in \resource\), we have \((4, 2) \sequence (5, 0) = (7,0)\).
\end{example}
 
As the value \(\max(p_1, q_0)\) is key for composing resource demands, we call it the \emph{disparity} of two resource demands.

\begin{definition}[Resource disparity]
   \label{def:resource-disparity}
   Let \((p_0, p_1), (q_0, q_1) \in \demand\), we define the \emph{disparity} of these resource demands as \(\max(p_1, q_0)\).
\end{definition}

\begin{theorem}
   Resource demands form a \emph{monoid} under sequencing.
\end{theorem}

\begin{proof}
   We provide a proof script in lean.
   \inputminted{lean}{formal-proofs/Resources/Monoid.lean}
\end{proof}


\section{Comparing Resource Pairs}

Whenever we define a programming language, we provide evaluation semantics and type rules, which we ultimately want to link by proving their \emph{soundness}. Soundness of a programming language with respect to evaluation semantics and type rules comprises two parts. First, we need to prove that the type we assign to an expression is consistent - evaluating the expression will produce a value of that type. Secondly, we need to show that the inferred resource demand is always \emph{at least} the concrete resource demand of evaluating an expression. In subsequent chapters, the main challenge of proving soundness will be in proving consistency of resource demands. 

In order to do this, we need to be able to compare resource demands. This ultimately motivates the definition of \emph{relaxation}, which induces a partial order on the set of resource demands. Ultimately, this will streamline future soundness proofs. Let us therefore begin by defining what it means for a resource demand to be a relaxation of another one. Intuitively, one resource demand is a relaxation of another resource demand, if the initial resources and the resource consumption are at least as large.

\begin{definition}[Relaxation]\label{def:relaxation}
   Let \((p_0, p_1), (q_0, q_1) \in \demand\). We define the relation \relaxation ~as follows:

   \[
      (p_0, p_1) \succcurlyeq (q_0, q_1) :\iff p_0 \geq q_0 \wedge p_0 - p_1 \geq q_0 - q_1
   \]
\end{definition}

We then say that \((p_0, p_1)\) is \emph{a relaxation of} \((q_0, q_1)\).

\todo{Introduce Visual representation}

\begin{example}
   \((4, 2) \relaxation (3, 2)\), as \(4 \geq 3\) and \(4 - 2 \geq 3 - 2\).
\end{example}

\begin{example}
   \((4,2) \notrelaxation (5, 4)\), as \(4 \centernot \geq 5\).
\end{example}

\begin{example}
   \((5, 4) \notrelaxation (2, 0)\), as \(5 - 4 \centernot{\geq} 2 - 0\).
\end{example}

Most notably, relaxation defines a partial ordering on the set of resource demands. Let us, therefore, define partial orders:

\begin{definition}[Partial Order]
   Let \(M\) be a set, and \(\leq\) be a relation on \(M\). A partial order satisfies the following properties for any \(a, b, c \in M\):
   \begin{enumerate}[label=\Roman*]
      \item Reflexivity: \(a \leq a \) 
      \item Anti-symmetry: \(a \leq b\) and \(b \leq a\), then \(a = b\) 
      \item Transitivity: \(a \leq b\) and \(b \leq c\), then \(a \leq c\)
   \end{enumerate}
\end{definition}

Before we can show that resource demands form a partial order under relaxation, we need to define equality for resource demands. Intuitively two resource demands are equal, if the respective initial cost is equal and the resource consumption is equal. 

\begin{lemma}
   The relaxation relation \(\relaxation\) defines a partial ordering on the set of resource demands.
\end{lemma}

\newpage

\begin{proof}
   We provide a lean proof script.
   \inputminted{lean}{formal-proofs/Resources/Relaxation_PO.lean}
\end{proof}

It is important to note that, for any two resource pairs, one \emph{need not} be a relaxation of the other. Therefore, relaxation does not define a total order - as the following example shows.

\begin{example}
   Let \((4,2), (5,4) \in \demand\). Then, \((4,2) \notrelaxation (5,4)\) \emph{and} \((5,4) \notrelaxation (4,2)\).
\end{example}

In \cref{chap:list-tick} we introduce potentials (\cref{chap:list-tick}), which increases the complexity of the proof of soundness (\cref{thm:soundness-7}). To streamline the proof, we introduce a lemma for easier manipulation of relaxations of resource demands.

For an arbitrary resource demand \((p_0, p_1) \in \demand\) and \(n, m \in \resource\), one may ask if \((p_0 + n, p_1 + m) \relaxation (p_0, p_1)\). As it turns out, this is true if and only if \(n - m \geq 0\). We begin by stating the lemma, visualizing it and lastly proving it.

\begin{lemma}\label{lemma:pos-relaxation}
   \((p_0, p_1) \in \demand\) and \(n, m \in \resource\) with \(n - m \geq 0\).

   \[
      (p_0 + n, p_1 + m) \relaxation (p_0, p_1)
   \]
\end{lemma}
\todo{Visualize, explain and proof lemma.}

