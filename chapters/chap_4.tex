\chapter{Resources}

Throughout this thesis, we introduce programming language constructs, in order to elicit resource consumption for programs. It is, therefore, important to mention that resources can be an arbitrary cost metric, including but not limited to: memory consumption, runtime, energy consumption. While the details of the respective type of resource are nuanced, the resource consumption generally comprises two parts: Resources consumed to start evaluating, and possibly, resources freed after evaluation.

We will associate resource consumption with resource pairs. We will then define multiplication on resource-pairs, which is intimately linked to sequential evaluation, as well as a partial ordering. The partial ordering will lead to the definition of \emph{relaxation} and allow us to compare the resource consumption of evaluations. 

\section{Resource Pairs}

We start by defining resource pairs. These pairs will fundamentally encode the cost of evaluating an expression. Most importantly, a resource pair only comprises \emph{positive} integers. 

\begin{definition}[Resources]
   We denote by \(\mathcal{R}\) the set of resource pairs, which we identify like so:
   \[
      \resource = \mathbb{N} \times \mathbb{N}
   \]
\end{definition}

\begin{definition}[Resource pair]
   \label{def:resource-pair}
   We define a \emph{resource pair} as a tuple, where \(p_0\) is the a priori resources needed, and \(p_1\) is the a posteriori resources reimbursed at the end.
   \[
      (p_0, p_1) \in \resource
   \]
\end{definition}

When reasoning about a resource pair \((p_0, p_1)\), we say that \(p_0\) are the \emph{initial} resources, and \(p_1\) are the \emph{residual} resources. 

\begin{example}
   A \nameref{def:resource-pair} with 4 initial and 2 residual resources is denoted by \((4, 2)\).
\end{example}

\begin{definition}[Resource Consumption]
   Given \((p_0, p_1) \in \resource\), we define the \emph{resource consumption} as the difference between initial and residual resources, \(p_0 - p_1\).
\end{definition}

\begin{example}
   For \((4, 2) \in \resource\), the resource consumption equals \(2\).
\end{example}

As most programs are made up of multiple subsequent evaluations, we need a mechanism for composing evaluations; More specifically, we need to define the resource cost of subsequent evaluations. 
For this, there are two cases: The first operation has enough residual resources for the second operation to be executed, or the second operation requires more initial resources than residual resources of the first operation. In the latter case we need to increase the initial resources of the composed evaluation.

This yields two cases for the resulting resource pair:
\[
   \begin{cases}
      (p_0 + q_0 - p_1,  q_1) & \mbox{if } q_0 \geq p_1 \\
      (p_0,q_1 + p_1 - q_0) & \mbox{if } q_0 <    p_1 
   \end{cases}
\]

We can, however, simplify the multiplication of resource-pairs by merging the two cases. Consider that \(p_0 - p_1 + \max(p_1, q_0)\) precisely matches the initial resources for both cases. Similarly, \(q_1 - q_0 + \max(p_1, q_0)\) precisely matches the residual resources for both cases. 
This yields the following definition:

\begin{definition}[Multiplying resource pairs]
   \label{def:multiplying-pairs}
   Let \((p_0, p_1)\) and \((q_0, q_1)\) be two \nameref{def:resource-pair}s, as introduced above. We then define:
   \[(p_0, p_1) \cdot (q_0, q_1) = (p_0 - p_1 + \max(p_1, q_0), q_1 - q_0 + \max(p_1, q_0))\]
\end{definition}

\begin{example}
   For \((4, 2), (5,0) \in \resource\), we have \((4, 2) \cdot (5, 0) = (7,0)\).
\end{example}

\begin{definition}[Resource disparity]
   Let \((p_0, p_1), (q_0, q_1) \in \resource\), we define the \emph{disparity} of these resource pairs as \(\max(p_1, q_0)\).
\end{definition}
\todo{Keep or dump?}

We remark that the multiplication on resource pairs forms a monoid.
\todo{Add Proof to appendix? Or proof in lean?}

\section{Comparing Resource Pairs}

Whenever we define a programming language, along with evaluation semantics and type rules, we want to proof soundness of that language with respect to evaluation semantics and type rules. With respect to resource consumption, soundness assures that the inferred resource consumption is never less than the concrete cost of evaluation. In order to reasons more precisely and concisely about the resource consumption, we define a partial ordering on the set of resources, which leads to the definition of \emph{relaxation}.

Intuitively, one resource pair is "smaller" than another resource pair, if the initial resources and the resource consumption are smaller:

\begin{definition}[Relaxation]\label{def:relaxation}
   Let \((p_0, p_1), (q_0, q_1) \in \resource\). We define the relation \relaxation ~as follows:

   \[
      (p_0, p_1) \succcurlyeq (q_0, q_1) :\iff p_0 \geq q_0 \wedge p_0 - p_1 \geq q_0 - q_1
   \]
\end{definition}

We then say that \((p_0, p_1)\) is \emph{a relaxation of} \((q_0, q_1)\).

\begin{example}
   \((4, 2) \relaxation (3, 2)\), as \(4 \geq 3\) and \(4 - 2 \geq 3 - 2\).
\end{example}

\begin{example}
   \((4,2) \notrelaxation (5, 4)\), as \(4 \centernot \geq 5\).
\end{example}

\begin{example}
   \((5, 4) \notrelaxation (2, 0)\), as \(5 - 4 \centernot{\geq} 2 - 0\).
\end{example}

Even more notably, for any two resource pairs, one \emph{need not} be a relaxation of the other. Therefore, relaxation does not define a total ordering - as the following example shows.

\begin{example}
   Let \((4,2), (5,4) \in \resource\). Then, \((4,2) \notrelaxation (5,4)\) \emph{and} \((5,4) \notrelaxation (4,2)\).
\end{example}

Most notably, this relation defines a partial ordering on the set of resource pairs. More specifically, a partial ordering satisfies the following properties for any elements \(a, b, c\):

\begin{align}
   & a \relaxation a \tag{reflexivity} \\
   & a \relaxation b \text{ and } b \relaxation a\text{, then } a = b \tag{anti-symmetry}\\
   & a \relaxation b \text{ and } b \relaxation c\text{, then } a \relaxation c. \tag{transitivity}
\end{align}

\begin{lemma}
   The relaxation relation defines a partial ordering on the set of resource pairs.
\end{lemma}

\begin{proof}
   We provide a proof script written in lean.
\end{proof}
\todo{Refer to it}



