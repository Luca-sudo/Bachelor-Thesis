\chapter{Resources}

Throughout this thesis, we introduce programming language constructs, in order to elicit resource consumption of programs. It is, therefore, important to mention that resources can be an arbitrary cost metric, including but not limited to: memory consumption, runtime, energy consumption. While the details of the respective type of resource are nuanced, the resource consumption generally comprises two parts: Resources consumed to start evaluating, and possibly, resources freed after evaluation.

Tracing resource consumption throughout the evaluation of a program may look like this:

\ctikzfig{resource_intro}

We are most interested in the value at the beginning and at the end, which leads us to simplify the resource consumption further. Drawing a straight line between resources at the start and at the end.

\ctikzfig{resource_reduced}

We use this visual representation to foster intuition throughout this chapter - illustrating examples and concepts.

This overarching structure of resource demands leads us to a refined version of \href{def:resource-consumption}{resource consumption}. Furthermore, we will define a rich structure on the resource demand of programs; Most notably, we introduce sequencing of resource demands, which gives rise to a monoidal structure, and relaxation, which defines a \emph{partial order} - allowing us to compare resource demands, in a way that is consistent with our intuition of cost.

\section{Resource Demand}

We start by defining resources mathematically, which will lead to defining resource demand of programs as a tuple of resources. Afterward, we introduce multiplication of these tuples and disambiguate reasoning about resource demand, by naming key figures of resource demands.

\begin{definition}[Resources]\label{def:resources}
   We identify resources with the natural numbers, where the value refers to an amount of resources.
   \[
      \resource = \mathbb{N}_0
   \]
\end{definition}


\begin{definition}[Resource demand]\label{def:resource-pair}
   We denote by \(\demand\) the set of resource demands, which is a pair of resources.
   \[
      \demand = \resource \times \resource
   \]
\end{definition}

When reasoning about a resource demand \((p_0, p_1) \in \demand\), \(p_0\) are the \emph{initial} resources, and \(p_1\) are the \emph{residual} resources. 

\begin{example}
   \((4, 2) \in \demand\)

Representing this resource demand using resource diagrams yields:

\ctikzfig{ex25}

\end{example}

It is important to distinguish the resource demand from the \emph{resource consumption}. The resource consumption of a program is precisely its residual resource subtracted from its initial resources. 

\begin{definition}[Resource Consumption]\label{def:resource-consumption}
   Given \((p_0, p_1) \in \demand\), we define the \emph{resource consumption} as the difference between initial and residual resources, \(p_0 - p_1\).
\end{definition}

While a resource demand is a pair of \emph{non-negative} integers, its resource consumption can be negative - this corresponds to a program that \emph{frees} resources instead of consuming them. We can think of the resource consumption as the directed (!) height of the associated resource diagram. Consider the following example.

\begin{example}
   For \((4, 2) \in \resource\), the resource consumption equals \(4 - 2 = 2\).

\ctikzfig{resource_consumption}

\end{example}

As most programs are made up of multiple subsequent evaluations, we need a mechanism for composing evaluations; More specifically, we need to define the resource cost of subsequent evaluations. 
For this, there are two cases: The first operation has enough residual resources for the second operation to be executed, or the second operation requires more initial resources than residual resources of the first operation provides. In the latter case we need to increase the initial resources of the composed evaluation.

This yields two cases for the resulting resource demand:
\[
   \begin{cases}
      (p_0 + q_0 - p_1,  q_1) & \mbox{if } q_0 \geq p_1 \\
      (p_0,q_1 + p_1 - q_0) & \mbox{if } q_0 <    p_1 
   \end{cases}
\]

For the first case, we lift the first resource demand so its residual resources match the initial resources of subsequent resource demand - allowing us to compose both resource demands.

\begin{align*}
   \tikzfig{sequencing_11} & \implies & \tikzfig{sequencing_12}
\end{align*}

The second case is similar, but we lift the second resource demand to match.

\begin{align*}
   \tikzfig{sequencing_21} & \implies & \tikzfig{sequencing_22}
\end{align*}

We can, however, simplify the multiplication of resource demands by merging the two cases. Consider that \(p_0 - p_1 + \max(p_1, q_0)\) precisely matches the initial resources for both cases. Similarly, \(q_1 - q_0 + \max(p_1, q_0)\) precisely matches the residual resources for both cases. 
This yields the following definition:

\begin{definition}[Sequencing resource demands]
   \label{def:multiplying-pairs}
   Let \((p_0, p_1)\) and \((q_0, q_1)\) be two \nameref{def:resource-pair}s, as introduced above. We then define:
   \[(p_0, p_1) \sequence (q_0, q_1) = (p_0 - p_1 + \max(p_1, q_0), q_1 - q_0 + \max(p_1, q_0))\]
\end{definition}

\begin{example}
   For \((4, 2), (5,0) \in \resource\), we have \((4, 2) \sequence (5, 0) = (7,0)\).

\begin{align*}
   \tikzfig{ex27I} & \implies & \tikzfig{ex27II}
\end{align*}

\end{example}
 
As the value \(\max(p_1, q_0)\) is key for composing resource demands, we call it the \emph{disparity} of two resource demands.

\begin{theorem}
   Resource demands form a \emph{monoid} under sequencing.
\end{theorem}

\begin{proof}
   We provide a proof script in lean.
   \inputminted{lean}{formal-proofs/Resources/Monoid.lean}
\end{proof}


\section{Comparing Resource Pairs}

Whenever we define a programming language, we provide evaluation semantics and type rules, which we ultimately want to link by proving their \emph{soundness}. Soundness of a programming language with respect to evaluation semantics and type rules comprises two parts. First, we need to prove that the type we assign to an expression is consistent - evaluating the expression will produce a value of that type. Secondly, we need to show that the inferred resource demand is always \emph{at least} the concrete resource demand of evaluating an expression. In subsequent chapters, the main challenge of proving soundness will be in proving consistency of resource demands. 

In order to do this, we need to be able to compare resource demands. This ultimately motivates the definition of \emph{relaxation}, which induces a partial order on the set of resource demands. Ultimately, this will streamline future soundness proofs. Let us therefore begin by defining what it means for a resource demand to be a relaxation of another one. Intuitively, one resource demand is a relaxation of another resource demand, if the initial resources \emph{and} the resource consumption are at least as large.

\begin{definition}[Relaxation]\label{def:relaxation}
   Let \((p_0, p_1), (q_0, q_1) \in \demand\). We define the relation \relaxation ~as follows:

   \[
      (p_0, p_1) \succcurlyeq (q_0, q_1) :\iff p_0 \geq q_0 \wedge p_0 - p_1 \geq q_0 - q_1
   \]
\end{definition}

We then say that \((p_0, p_1)\) is \emph{a relaxation of} \((q_0, q_1)\). Relaxation has a visual interpretation in resource diagrams: The relaxed resource demand has to start at least the same height \emph{and} be at least as long as the resource demand compared to. We illustrate this with examples below.

\begin{example}
   \((4, 2) \relaxation (3, 2)\)

Here both constraints are satisfied, \(4 \geq 3\) and \(4 - 2 \geq 3 - 2\). We see: (1) The first resource demand has a higher starting point, indicating higher initial resources. (2) The first resource demand is vertically longer, which indicates larger resource consumption.

\ctikzfig{ex210}

\end{example}

\begin{example}
   \((4,2) \notrelaxation (5, 4)\)

As \(4 \centernot{\geq} 5\) we have less initial resources. Thus, \((4,2)\) \emph{cannot} be a relaxation. In the diagram below we see that the first resource demand begins at a lower point.

\ctikzfig{ex211}

\end{example}

\begin{example}
   \((5, 4) \notrelaxation (2, 0)\)

For this example it holds that \(5 - 4 \centernot{\geq} 2 - 0\), which violates a constraint for relaxation - the first resource demand consumes \emph{less} resources. In the diagram below, this correlates to the first resource demand being vertically smaller than the second one.

\ctikzfig{ex212}

\end{example}

Most notably, relaxation defines a partial ordering on the set of resource demands. Let us recall the definition of \emph{partial orders}:

\begin{definition}[Partial Order]
   Let \(M\) be a set, and \(\leq\) be a relation on \(M\). A partial order satisfies the following properties for any \(a, b, c \in M\):
   \begin{enumerate}[label=\Roman*]
      \item Reflexivity: \(a \leq a \) 
      \item Anti-symmetry: \(a \leq b\) and \(b \leq a\), then \(a = b\) 
      \item Transitivity: \(a \leq b\) and \(b \leq c\), then \(a \leq c\)
   \end{enumerate}
\end{definition}

Before we can show that resource demands form a partial order under relaxation, we need to define equality for resource demands. Intuitively two resource demands are equal, if the respective initial cost is equal and the resource consumption is equal. 

\begin{lemma}
   The relaxation relation \(\relaxation\) defines a partial ordering on the set of resource demands.
\end{lemma}

\begin{proof}
   We provide a lean proof script.
   \inputminted{lean}{formal-proofs/Resources/Relaxation_PO.lean}
\end{proof}

It is important to note that, for any two resource pairs, one \emph{need not} be a relaxation of the other. Therefore, relaxation does not define a total order - as the following example shows.

\begin{example}
   Let \((4,2), (5,4) \in \demand\). Then, \((4,2) \notrelaxation (5,4)\) \emph{and} \((5,4) \notrelaxation (4,2)\).
\end{example}

In later chapters (\cref{chap:list-tick}), the introduction of potentials increases the complexity of the proof of soundness (\cref{thm:soundness-7}). To streamline the proof, we introduce a lemma for easier manipulation of relaxations of resource demands.

For an arbitrary resource demand \((p_0, p_1) \in \demand\) and \(n, m \in \resource\), one may ask if \((p_0 + n, p_1 + m) \relaxation (p_0, p_1)\). As it turns out, this is true if and only if \(n - m \geq 0\). This agrees with our intuition: Enforcing that \(n - m \geq 0\) ensures that the resource consumption does not decrease - keeping relaxation constraints sound.

\begin{lemma}\label{lemma:pos-relaxation}
   \((p_0, p_1) \in \demand\) and \(n, m \in \resource\) with \(n - m \geq 0\).

   \[
      (p_0 + n, p_1 + m) \relaxation (p_0, p_1)
   \]
\end{lemma}

\begin{proof}
   The first inequality, \(p_0 + n \geq p_0\), trivially holds as \(n \in \resource\) implies that \(n \geq 0\). 

   For the second inequality, we get \(p_0 + n - (p_1 + m) \geq p_0 - p_1\), which is equivalent to \((p_0 - p_1) + (n - m) \geq p_0 - p_1\). By assumption \(n - m \geq 0\). Thus, this inequality also holds.
\end{proof}

