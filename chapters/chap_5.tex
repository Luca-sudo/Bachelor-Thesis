\chapter{LetTick Language}

In this chapter, we introduce our first programming language. This language will be the core, subsequent chapters will extend this language incrementally. To this end, we define the type system, along with the associated evaluation semantics and type rules. The chapter then concludes with a proof of soundness, showing that the relation between evaluation semantics and type rules is consistent - the resource bounds assigned to types provide a true lower bound on the concrete resource consumption of evaluating an expression.

In order to elicit resource bounds for programs, we need two things: (1) A construct in the programming language that allows altering the resource demand and (2) types that reflect the resource demand. The first problem is solved by introducing the instruction \(\tick{k}\), where \(k\) is an integer, indicating the amount of resources that are either consumed of freed. The second problem is solved by embellishing the return type with a resource demand.

\section{Language Syntax and Type System}
We begin by defining the programming language and the associated type system below:

\begin{definition}[let-tick language]
   \label{def:prog-lang-4}

\begin{align*}
   e := ~~~ & \letexp{\_}{e_1}{e_2}             & \text{(let)}\\
            & \tick{q}                         & \text{(tick)}
\end{align*}
\end{definition}

\begin{definition}[Type System]\label{fig:type-system}
   \[\type := \unit \]
\end{definition}

\section{Evaluation Semantics}
In this section, we define what it means for a program to consume (or free) resources, by defining the evaluation semantics needed. To this end, we write \(\evals{}{e}{v}{}{}\) for the fact the expression \(e\) evaluates to the value \(v\). In order to capture resource-consumption, we augment this notation like this: \(\evals{}{e}{v}{p_0}{p_1}\), where \((p_0, p_1) \in \demand\). 


\begin{definition}[Evaluation Judgement]\label{def:evaluation-judgement}
   Let \(e\) be an expression of our programming language, let \(v\) be the value that is obtained from evaluating \(e\). Furthermore, let \((p_0, p_1) \in \demand\). 
   Where \(p_0\) are the initial resources needed to evaluate \(e\), and \(p_1\) resources are freed afterward.
   
   \[
      \evals{}{e}{v}{p_0}{p_1}
   \]
\end{definition}

We will now define rules for the evaluation of programming language constructs, in the form of evaluation semantics. This will allow us to later solve a list of numeric constraints to arrive at the specific resource-consumption of evaluating an expression.
First, we need a rule that allows us to combine two expression into a let expression. We also need to, however, provide resource annotations for the resulting let expression. Therefore, we also need to add numeric constraints, resulting in the following rule:

\[
   \inference[(E:let)]
   {\evals{}{e_1}{()}{p_0}{p_1} ~~,~~ \evals{}{e_2}{()}{q_0}{q_1}}
   {\evals{}{\letexp{}{e_1}{e_1}}{()}{r_0}{r_1}}
   \qquad
   \begin{aligned}
      \text{where }  &r_0 = p_0 - p_1 + \max(p_1, q_0)\\
                     &r_1 = q_1 - q_0 + \max(p_1, q_0) 
   \end{aligned}
\]

Similarly, we now define a rule for the \<tick> instruction. The expression \<tick> \(q\) consumes precisely \(q\) resources; or frees \(q\) resources, should the amount be negative. These two cases translate directly into two evaluation rules, provided below:

\[
   \inference[\((E:tick_{+})\)]
   {q \geq 0}
   {\evals{}{\tick{q}}{()}{q}{}}
\]

\[
   \inference[\((E:tick_{-})\)]
   {q < 0}
   {\evals{}{\tick{q}}{()}{}{|q|}}
\]

In the next section, we introduce type rules that are tightly linked to the operational semantics defined now. 

\section{Type Rules}
The evaluation judgement in the previous section defined our \emph{ground truth}; That is, using the rules defined there, we can exactly calculate the resource-consumption of an arbitrary, \textbf{well-formed} expression. The type rules introduced in this chapter will allow us to assign a type to an expression, where the resource-annotations of that type provide an \textbf{lower-bound} on the resource-consumption. As a result, type inference can be used to determine a lower bound on the resource consumption, without executing a program.

\subsection{Resource-aware Type System}

We start by introducing \emph{resource-aware types}, which comprise two parts: the type assigned to an expression, together with a resource-pair representing the inferred resource consumption. To this end, we provide an ergonomic notation for resource-aware types:

\begin{definition}[Resource-aware types]\label{def:ra-type}
   Let \(A \in \type\) and \((p_0, p_1) \in \demand\). We define resource-aware types as tuples \((A, (p_0, p_1)) \in \type \times \demand\).
\end{definition}

Most of the time we write \(\ratype{A}{p_0}{p_1}\) for \((A, (p_0, p_1))\). For this chapter, the only type that \(A\) can adopt is that of \(\unit\). Therefore, resource-aware types have the form \(\ratype{\unit}{p_0}{p_1}\) for this chapter. To acquaint the reader with the new notation, consider the example below.

\begin{example}
   \(\typing{}{e}{\ratype{\unit}{4}{2}}\) is a judgement, claiming that the expression \(e\) produces a value of type \(\unit\), with a resource demand of 4 initial resources and 2 residual resources.
\end{example}

\subsection{Inference Rules}

We need to define two rules, one for each language construct each. Similarly to the composition of resource-annotations in the previous section on evaluation semantics, we define the cost of sequential operations in a let expression as the product of the respective resource pairs.

This yields the following rules:
\[
   \label{def:tr-let-4}
   \vcenter{\hbox{
      \inference[(T:let)]
      {\typing{}{e_1}{\ratype{\unit}{p_0}{p_1}},  \typing{}{e_2}{\ratype{\unit}{q_0}{q_1}}}
      {\typing{}{\letexp{\_}{e_1}{e_2}}{\ratype{\unit}{r_0}{r_1}}}
}}\qquad \begin{aligned}
      r_0 = p_0 - p_1 + \max(p_1, q_0) \\
      r_1 = q_1 - q_0 + \max(p_1, q_0)
   \end{aligned}
\]

\begin{remark}
   Note that \((r_0, r_1) = (p_0, p_1) \cdot (q_0, q_1)\).
\end{remark}

\[
   \label{def:tr-tick-4}
   \inference[(T:tick)]
   {q_0 \geq k + q_1}
   {\typing{}{\tick{k}}{\ratype{\unit}{q_0}{q_1}}}
\]


Let us now perform an exemplary type derivation for a simple program, using the type rules we just introduced, to get a better understanding of how the definitions orchestrate together. For this, consider the following program:

\begin{example}
   \begin{align*}
   \letexp{\_}{\tick{3}}{} \\
   \letexp{\_}{\tick{-2}}{} \\
   \tick{5}
   \end{align*}
\end{example}

Intuitively, we have three distinct steps, the first one consuming 3 resources, the second one freeing up 2 resources and the last one consuming 5 resources. Let us now derive a typing for the program.

\[
   \inference
   {
      \inference
      {q_0 \geq 3 + q_1}
      {\typing{}{\tick{3}}{\ratype{\unit}{q_0}{q_1}}}
       &
      \inference
      {
         \inference
         {t_0 \geq -2 + t_1}
         {\typing{}{\tick{-2}}{\ratype{\unit}{t_0}{t_1}}}
          &
         \inference
         {s_0 \geq 5 + s_1}
         {\typing{}{\tick{5}}{\ratype{\unit}{s_0}{s_1}}}
      }
      {\typing{}{\letexp{\_}{\tick{-2}}{\tick{5}}}{\ratype{\unit}{r_0}{r_1}}}
   }
   {\typing{}{\letexp{\_}{\tick{3}}{\letexp{\_}{\tick{-2}}{\tick{5}}}}{\ratype{\unit}{p_0}{p_1}}}
\]

\begin{align*}
   \text{Where }  & r_0 = t_0 - t_1 + \max(t_1, s_0) \\
                  & r_1 = s_1 - s_0 + \max(t_1, s_0) \\
                  & p_0 = q_0 - q_1 + \max(q_1, r_0) \\
                  & p_1 = r_1 - r_1 + \max(q_1, r_0) \\
\end{align*}


We are now left with the task of resolving the collected, numeric constraints. In concrete implementations, this would be done by an LP-solver. As a result of applying the (T:tick) rule for the three instances of \(\tick{}\) expressions, we get the following values: \(q_0 = 3, t_1 = 2, s_0 = 5, q_1 = t_0 = s_1 = 0\). Using these values, we are able to compute the intermediary values \(r_0, r_1, p_0, p_1\), resulting in:

\[
   p_0 = 6 \qquad p_1 = 0
\]

This completes our type derivation, as inserting the calculated resource-annotations yields our desired type. The resulting type judgement is: 
\[
   \<let> \_ = \<tick>~3~\<in> ~ \<let> \_ = \<tick>~-2~\<in>~ \<tick>~5 : \ratype{\unit}{6}{0}
\]

The resulting type \(\ratype{\unit}{6}{0}\) indeed furnishes a tight bound on the resources required. Having a solid grasp of how the type rules orchestrate together, having exercised a simple example, we now prove soundness for the \emph{let-tick} programming language.


\section{Soundness}
Ultimately, we want our type rules to be consistent with the operational semantics defined previously. This will allow us to reason about the type of a program, while ensuring that the resource-annotations of the resulting type line up with the concrete resource consumption of the expression.

Let us first sketch the structure of our soundness proof:

If \(\typing{}{e}{\ratype{\unit}{p_0}{p_1}}\) and \(\evals{}{e}{()}{q_0}{q_1}\), then the following hold true:
The result \(()\) of the expression \(e\) has a type that is consistent with the one assigned to \(e\). The initial resources of the type are not exceeded in the concrete evaluation of the expression \(e\). The resource consumption assigned to the type is not exceeded by the evaluation, either. We can state the same more precisely, by using the relaxation relation defined in \cref{def:relaxation}, yielding the following theorem:

\begin{theorem}[Soundness of typing for let-tick language]
   Let e be an expression in our programming language, and let \((q_0, q_1), (p_0, p_1) \in \resource\). 
   \center If \(\typing{}{e}{\ratype{\unit}{p_0}{p_1}}\) and \(\evals{}{e}{()}{q_0}{q_1}\), then \((p_0, p_1) \relaxation (q_0, q_1)\).
\end{theorem}

\begin{proof}
In the first part, I prove that the inequality \(p_0 \geq q_0\) holds. We use structural induction on the type derivation of the expression, which concretely means, we assume that the expression \(e\) has the type \(\typing{}{e}{\ratype{\unit}{p_0}{p_1}}\) and that the expression evaluates, like so \(\evals{}{e}{()}{q_0}{q_1}\). We now need to prove that, for every type rule that could be the last rule applied in a type derivation, the inequality holds.

   (tick): We make a case distinction. Let \(q \geq 0\). Then the following hold by assumption:
   \begin{align}
      q     &\geq 0 \label{4.1}\\
      q_0   &= q \label{4.2}\\
      q_1   &= 0 \label{4.3}\\
      p_0   &\geq q + p_1 \label{4.4}
   \end{align}
   Since \(p_1 \geq 0\) by definition, using \ref{4.4}, \(p_0 \geq q\) holds. Applying this inequality to \ref{4.2}, we get that \(p_0 \geq q_0\). Which proves the first part.
   Next, we show \(p_0 - p_1 \geq q_0 - q_1\). Combining \ref{4.4} with \ref{4.2}, we get \(p_0 \geq q_0 + p_1\). Subtracting \(p_1\) from both sides, we get \(p_0 - p_1 \geq q_0\). Since \(q_1 \geq 0\) by definition as well, it especially holds that \(p_0 - p_1 \geq q_0 - q_1\). Which concludes the proof for the case of \(q \geq 0\).
   For the second case, we assume that \(q < 0\). Then, the following hold:
   \begin{align}
      q_1   &= q \label{4.5}\\
      q_0   &= 0 \label{4.6}
   \end{align}
   Furthermore, \ref{4.1} and \ref{4.4} also hold true. By definition \(p_0 \geq 0\) holds. Using \ref{4.6}, we get \(p_0 \geq q_0\). 
   Let us now prove soundness with respect to resource consumption. Subtracting \(p_1\) from both sides in \ref{4.4}, we get \(p_0 - p_1 \geq q \). Applying \cref{4.5}, we get \(p_0 - p_1 \geq q_1\). Because \(q_1 \geq 0\) by definition, it also holds that \(p_0 - p_1 \geq 0 - q_1\). Using \ref{4.6}, we get \(p_0 - p_1 \geq q_0 - q_1\), concluding our proof for tick.

   (let):  If the let rule was applied, the expression has the form \(\letexp{\_}{e_1}{e_2}\). Our induction hypothesis includes judgements, and soundness, for the sub-expressions \(e_1, e_2\). We list all assumptions below:
   \begin{align*}
      &\typing{}{e_1}{\ratype{\unit}{p_0}{p_1}}                   & &(p_0, p_1)\relaxation (m_0, m_1)\\
      &\evals{}{e_1}{v_1}{m_0}{m_1}                               & &(q_0, q_1)\relaxation (n_0, n_1)\\
      &\typing{}{e_2}{\ratype{\unit}{q_0}{q_1}}                   & & r_0= p_0 - p_1 + \max(p_1, q_0) \\
      &\evals{}{e_2}{v_2}{n_0}{n_1}                               & & r_1= q_1 - q_0 + \max(p_1, q_0) \\
      &\typing{}{\letexp{\_}{e_1}{e_2}}{\ratype{\unit}{r_0}{r_1}} & & s_0= m_0 - m_1 + \max(m_1, n_0) \\
      &\evals{}{\letexp{\_}{e_1}{e_2}}{v_2}{s_0}{s_1}             & & s_1= n_1 - n_0 + \max(m_1, n_0) 
   \end{align*}
   
   To prove soundness for the let expression, we need to prove \((r_0, r_1) \relaxation (s_0, s_1)\). We do this by proving soundness for two mutually exclusive conditions: \(n_0 \geq m_1\) and \(n_0 < m_1\). Before introducing the case distinction, we prove soundness for the resource consumption in the general case:
   \begin{align}
      s_0 - s_1   &= m_0 - m_1 + \max(m_1, s_0) - (n_1 - n_0 + \max(m_1, s_0)) \\
                  &= m_0 - m_1 + n_0 - n_1 + \max(m_1, s_0) - \max(m_1, s_0) \\
                  &= m_0 - m_1 + n_0 - n_1 \\
                  &\leq p_0 - p_1 + q_0 - q_1 \label{eqn:3.16}\\
                  &= p_0 - p_1 + \max(p_1, q_0) + q_0 - q_1 - \max(p_1, q_0) \\
                  &= \underbrace{p_0 - p_1 + \max(p_1, q_0)}_{= r_0} - \underbrace{(q_1 - q_0 + \max(p_1, q_0))}_{= r_1}
   \end{align}

   Where \cref{eqn:3.16} uses \((p_0, p_1) \relaxation (m_0, m_1), (q_0, q_1) \relaxation (n_0, n_1)\). We have proven \(r_0 - r_1 \geq s_0 - s_1\). Next, we prove \(r_0 \geq s_0\) by means of case distinction. 
   
   Let \(n_0 \geq m_1\).
   \begin{align}
      s_0   &= m_0 - m_1 + \max(m_1, n_0) \\
            &= m_0 - m_1 + n_0 \\
            &\leq p_0 - p_1 + n_0 \label{eqn:3.9}\\
            &\leq p_0 - p_1 + q_0 \label{eqn:3.10}\\
            &\leq p_0 - p_1 + \max(p_1, q_0) \\
            &= r_0
   \end{align}
   
   Where \cref{eqn:3.9} and \cref{eqn:3.10} are justified by \((p_0, p_1) \relaxation (m_0, m_1)\) and \((q_0, q_1) \relaxation (n_0, n_1)\), respectively. Next, we prove that \(r_0 - r_1 \geq s_0 - s_1\).

   Let \(n_0 < m_1\). 
   \begin{align}
      s_0   &= m_0 - m_1 + \max(m_1, n_0) \\
            &= m_0 - m_1 + m_1 \\
            &= m_0 \\
            &\leq p_0 \label{eqn:3.22}\\
            &\leq p_0 - p_1 + \max(p_1, q_0) = r_0 \label{eqn:3.23}
   \end{align}

   Where \cref{eqn:3.22} uses \((p_0, p_1) \relaxation (m_0, m_1)\), and \cref{eqn:3.23} uses the fact that \(\max(p_1, q_0) - p_1 \geq 0\) for any \(p_1, q_0\).

   This concludes our proof of soundness.
\end{proof}
