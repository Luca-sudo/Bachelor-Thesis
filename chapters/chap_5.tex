\chapter{LetTick Language}

\APm{previous chapter: Introduce ``Resources'' in a previous chapter.}

\AP{
Structure:
\begin{enumerate}
   \item i. Syntax, ii. Simple type system
   \item i. evaluation semantics (resource-aware)
   \item i. resource-aware type system
         ii. inference rules
   \item soundness
\end{enumerate}
}

In this chapter, we define the type system, along with the associated operational semantics and type rules, for a simple system, that only counts the amount of ticks in a program. The chapter concludes with a soundness proof, showing that the relation between operational semantics is consistent - the resource bounds assigned to types provide a true upper bound on the concrete resource consumption of evaluating an expression.
In order to elicit resource bounds for programs, we need two things: (1) A construct in the programming language that allows altering the calculated resource consumption and (2) types that reflect resource consumption. The first problem is solved by introducing the instruction \(\<tick>~q\) to the programming language. Where \(q\) is a rational number, indicating the amount of resources that are either consumed of freed. The second problem is solved by embellishing the unit type with two resource annotations, one for the resources required a priori, and another for the resources freed afterward.

\section{Language Syntax and Type System}
Below, we define the programming language for this chapter.

\begin{definition}[let-tick language]
   \label{def:prog-lang-4}

\begin{align*}
   e := ~~~ & \letexp{\_}{e_1}{e_2}             & \text{(let)}\\
            & \tick{q}                         & \text{(tick)}
\end{align*}

\APm{Add the basic type system here (without resource annotations)}

\end{definition}

\section{Big-step Operation Semantics}
In this section, we define what it means for a program to consume (or free) resources, by defining the operational semantics needed. To this end, we write \(\evals{}{e}{v}{}{}\) for the fact the expression \(e\) evaluates to the value \(v\). In order to capture resource-consumption, we augment this notation like this: \(\evals{}{e}{v}{p_0}{p_1}\), where \(p_0\) and \(p_1\) are positive rational numbers, \(p_0\) being the amount of resources needed to start evaluating the expression, and \(p_1\) being the resources freed after the evaluation of expression \(e\).
This yields the following definitions:


\begin{definition}[Evaluation Judgement]\label{def:evaluation-judgement}
   Let \(e\) be an expression of our programming language, let \(v\) be the value that is obtained from evaluating \(e\). Furthermore, let \((p_0, p_1)\) be a \nameref{def:resource-pair}.
   The \emph{evaluation judgement} encodes A judgement of the form  encodes that the expression e is evaluated to the value v, with \(p_0\) resources needed upfront, and \(p_1\) resources being freed afterward.
   \[
      \evals{}{e}{v}{p_0}{p_1}
   \]
\end{definition}

It is important to differentiate between the resources required by an expression, and the resources \emph{consumed} by an expression. In the above definition, the expression requires \(p\) resources a priori, whereas its resource consumption amounts to \(p - p'\); That is, the resource consumption is precisely the resources needed upfront, minus the resources that are freed in the end.

The first case is relevant, if the resources required by the second operation are exceeded, which is equivalent to \(q_0 \geq p_1\). In this case, we need to increase the initial resources by the difference between the reimbursement of the first operation and the cost of second operation. For the second case, the resources that are reimbursed suffice to start the second operation. As a result, we do not need to increase the initial cost, but increase the final reimbursement. It becomes apparent, that the difference between the resource reimbursement of the first operation and the resource requirement of the second operation has a key role in determining the resulting cost. We, therefore, give this metric a distinguished name:

\begin{definition}[Resource disparity] \label{def:resource-disparity}
   Let \((p_0, p_1)\) and \((q_0, q_1)\) be two \nameref{def:resource-pair}s, of subsequent operations, as introduced above. We then define the \textbf{disparity} of these two operations as \(\max(p_1, q_0)\).
\end{definition}



Having this definition in place, allows us to compose evaluations together, and yield the resource consumption of their subsequent execution. We will now define rules for the evaluation of programming language constructs, in the form of operational semantics. This will allow us to later solve a list of numeric constraints to arrive at the specific resource-consumption of evaluating an expression.
First, we need a rule that allows us to combine two expression into a let expression. We also need to, however, provide resource annotations for the resulting let expression. Therefore, we also need to add numeric constraints, resulting in the following rule:

\[
   \inference[(let)]
   {\evals{}{e_1}{()}{p_0}{p_1} ~~,~~ \evals{}{e_2}{()}{q_0}{q_1}}
   {\evals{}{\letexp{}{e_1}{e_1}}{()}{p_0 - p_1}{q_1 - q_0}}
\]
\todo{Introduce rule as split case? See below.}

Similarly, we now define a rule for the \<tick> instruction. The expression \<tick> \(q\) consumes precisely \(q\) resources; or frees \(q\) resources, should the amount be negative. These two cases translate directly into two inference rules, provided below:

\[
   \inference[\((E:tick_{+})\)]
   {q \geq 0}
   {\evals{}{\tick{q}}{()}{q}{}}
\]

\[
   \inference[\((E:tick_{-})\)]
   {q < 0}
   {\evals{}{\tick{q}}{()}{}{-q}}
\]

In the next section, we introduce type rules that are tightly linked to the operational semantics defined now. Afterward, we will prove the soundness theorem, providing a correspondence between operational semantics and type rules. 

\section{Type Rules}
The evaluation judgement in the previous section defined our \emph{ground truth}; That is, using the rules defined there, we can exactly calculate the resource-consumption of an arbitrary, \textbf{well-formed} expression. The type rules introduced in this chapter will allow us to assign a type to an expression, where the resource-annotations of that type provide an \textbf{upper-bound} on the resource-consumption. As a result, type inference can be used to determine an upper bound on the resource consumption, without executing a program.

For now, our programming language only constructs values of type \(\unit\). As a result, our type system only comprises the unit type. Contrary to that, the \nameref{def:evaluation-judgement} features resource-annotations. To embed the resource-pair into the type signature of an expression, we define the following notation:

\begin{definition}[Resource-annotated types]\label{def:ra-type}
   Let \(A\) be a type, and let \((p_0, p_1)\) be a \nameref{def:resource-pair}. The resource-annotated type then refers to a tuple comprising the type and the resource-pair.

   \[A^{p_0}_{p_1} = (A, (p_0, p_1))\] 

\end{definition}
\todo{weirdly written?}

For this chapter, the only type that \(A\) can adopt is that of \(\unit\). The above definition, however, will be valid even once we extend our type system with types besides unit. Below is a figure containing the type system of our language:

\begin{figure}[h] \label{fig:type-system}
   \[A := \unit \]
   \caption{Type system with resource-annotated unit type.}
\end{figure}

Similarly to the previous section on operational semantics, we define two rules, one for \textbf{let} expressions and one for \textbf{tick}. Before we can introduce the rule for \textbf{let}, however, we need to define how resource-annotations of types propagate. This corresponds to calculating the resource consumption of two subsequent evaluations, as defined in \cref{def:resource-pairs}. For this, consider the following example:

\[
   \inference[]
   {\typing{}{e_1}{\ratype{\unit}{p_0}{p_1}}, \typing{}{e_2}{\ratype{\unit}{q_0}{q_1}}}
   {\typing{}{\letexp{\_}{e_1}{e_2}}{?}}
\]

Similarly to the composition of resource-annotations in the previous section on operational semantics, we could initially define the product of resource-annotated types using a case distinction similar to the previous section. Here, however, we skip this step and directly define the product using the \nameref{def:resource-disparity}.

This yields the following rules:

\[
   \label{def:tr-let-4}
   \inference[(T:let)]
   {\typing{}{e_1}{\ratype{\unit}{p_0}{p_1}},  \typing{}{e_2}{\ratype{\unit}{q_0}{q_1}}}
   {\typing{}{\letexp{\_}{e_1}{e_2}}{\ratype{\unit}{p_0 - p_1 + \max(p_1, q_0)}{q_1 - q_0 + \max(p_1, q_0)}}}
\]

\[
   \label{def:tr-tick-4}
   \inference[(T:tick)]
   {q_0 \geq k + q_1}
   {\typing{}{\tick{k}}{\ratype{\unit}{q_0}{q_1}}}
\]

Let us now perform an exemplary type derivation for a simple program, using the type rules we just introduced, to get a better understanding of how the definitions orchestrate together. For this, consider the following program:

\[
   \letexp{\_}{\tick{3}}{\letexp{\_}{\tick{-2}}{\tick{5}}}
\]

Intuitively, we have three distinct steps, the first one consuming 3 resources, the second one freeing up 2 resources and the last one consuming 5 resources. Let us now derive a typing for the program.

\[
   \inference
   {
      \inference
      {q_0 \geq 3 + q_1}
      {\typing{}{\tick{3}}{\ratype{\unit}{q_0}{q_1}}}
       &
      \inference
      {
         \inference
         {t_0 \geq -2 + t_1}
         {\typing{}{\tick{-2}}{\ratype{\unit}{t_0}{t_1}}}
          &
         \inference
         {s_0 \geq 5 + s_1}
         {\typing{}{\tick{5}}{\ratype{\unit}{s_0}{s_1}}}
      }
      {\typing{}{\letexp{\_}{\tick{-2}}{\tick{5}}}{\ratype{\unit}{r_0}{r_1}}}
   }
   {\typing{}{\letexp{\_}{\tick{3}}{\letexp{\_}{\tick{-2}}{\tick{5}}}}{\ratype{\unit}{p_0}{p_1}}}
\]

\begin{align*}
   \text{Where }  & r_0 = t_0 - t_1 + \max(t_1, s_0) \\
                  & r_1 = s_1 - s_0 + \max(t_1, s_0) \\
                  & p_0 = q_0 - q_1 + \max(q_1, r_0) \\
                  & p_1 = r_1 - r_1 + \max(q_1, r_0) \\
\end{align*}

We are now left with the task of resolving the collected, numeric constraints. As a result of applying the (T:tick) rule for the three instances of \(\tick{}\) expressions, we get the following values: \(q_0 = 3, t_1 = 2, s_0 = 5, q_1 = t_0 = s_1 = 0\). Using these values, we are able to compute the intermediary values \(r_0, r_1, p_0, p_1\), resulting in:

\[
   p_0 = 6 \qquad p_1 = 0
\]

This completes our type derivation, as inserting the calculated resource-annotations yields our desired type. The resulting type judgement is: 
\[
   \<let> \_ = \<tick>~3~\<in> ~ \<let> \_ = \<tick>~-2~\<in>~ \<tick>~5 : \ratype{\unit}{6}{0}
\]

The resulting type \(\ratype{\unit}{6}{0}\) indeed furnishes a tight bound on the resources required. Having a solid grasp of how the type rules orchestrate together, having exercised a simple example, we now prove soundness for the \emph{let-tick} programming language.


\section{Soundness}
Ultimately, we want our type rules to be consistent with the operational semantics defined previously. This will allow us to reason about the type of a program, while ensuring that the resource-annotations of the resulting type line up with the concrete resource consumption of the expression.

Let us first sketch the structure of our soundness proof:

If \(\typing{}{e}{\ratype{\unit}{p_0}{p_1}}\) and \(\evals{}{e}{()}{q_0}{q_1}\), then the following hold true:
The result \(()\) of the expression \(e\) has a type that is consistent with the one assigned to \(e\). The a priori resource annotation of the type is not exceeded in the concrete evaluation of the expression \(e\). The resource consumption assigned to the type is not exceeded by the evaluation, either. We can state the same more precisely, like so: 

\begin{itemize}
   \item \(p_0 \geq q_0\)     
   \item \(p_0 - p_1 \geq q_0 - q_1\)
\end{itemize}

The first bullet point capturing that the result of evaluating the expression \(e\) has the type that was constructed using the type rules. The second bullet point stating that the \emph{a priori} resource bound that was constructed using the type rules is an upper bound on the concrete resources required a priori. And the third point stating that the resource consumption of the constructed type also provides an upper bound on the concrete resource consumption.

\begin{theorem}[Soundness of typing for let-tick language]
   Let e be an expression in our programming language, and let \((q_0, q_1)\) and \((p_0, p_1)\) be \nameref{def:resource-pair}s. If \(\typing{}{e}{\ratype{\unit}{p_0}{p_1}}\) and \(\evals{}{e}{()}{q_0}{q_1}\), then \(p_0 \geq q_0\) and \(p_0 - p_1 \geq q_0 - q_1\).
\end{theorem}

In the first part, I prove that the inequality \(p_0 \geq q_0\) holds. We use structural induction, which concretely means, we assume that the expression \(e\) has the type \(\typing{}{e}{\ratype{\unit}{p_0}{p_1}}\) and that the expression evaluates, like so \(\evals{}{e}{()}{q_0}{q_1}\). We now need to prove that, for every type rule that could be the last rule applied in a type derivation, the inequality holds.

\begin{proof}
   (tick): We make a case distinction. Let \(q \geq 0\). Then the following hold by assumption:
   \begin{align}
      q     &\geq 0 \label{4.1}\\
      q_0   &= q \label{4.2}\\
      q_1   &= 0 \label{4.3}\\
      p_0   &\geq q + p_1 \label{4.4}
   \end{align}
   Since \(p_1 \geq 0\) by definition, we can infer from \ref{4.4} that \(p_0 \geq q\) holds. Applying this inequality to \ref{4.2}, we get that \(p_0 \geq q_0\). Which proves the first part.
   Next, we show \(p_0 - p_1 \geq q_0 - q_1\). Combining \ref{4.4} with \ref{4.2}, we get \(p_0 \geq q_0 + p_1\). Subtracting \(p_1\) from both sides, we get \(p_0 - p_1 \geq q_0\). Since \(q_1 \geq 0\) by definition as well, it especially holds that \(p_0 - p_1 \geq q_0 - q_1\). Which concludes the proof for the case of \(q \geq 0\).
   For the second case, we assume that \(q < 0\). Then, the following hold:
   \begin{align}
      q_1   &= q \label{4.5}\\
      q_0   &= 0 \label{4.6}
   \end{align}
   Furthermore, \ref{4.1} and \ref{4.4} also hold true. By definition \(p_0 \geq 0\) holds. Using \ref{4.6}, we get \(p_0 \geq q_0\). 
   Let us now prove the second part. Subtracting \(p_1\) from both sides in \ref{4.4}, we get \(p_0 - p_1 \geq q \). Applying \cref{4.5}, we get \(p_0 - p_1 \geq q_1\). Because \(q_1 \geq 0\) by definition, it also holds that \(p_0 - p_1 \geq 0 - q_1\). Using \ref{4.6}, we get \(p_0 - p_1 \geq q_0 - q_1\), concluding our proof for tick.
   \todo{Add case distinction into type rules, or explain why that holds.}
      
   (let): By assumption, we get that \(\typing{}{\letexp{\_}{e_1}{e_2}}{\ratype{\unit}{p_0 - p_1 \max(p_1, q_0)}{q_1 - q_0 \max(p_1, q_0)}}\), and similarly \(\evals{}{\letexp{\_}{e_1}{e_2}}{()}{r_0 - r_1 + \max(s_0, r_1)}{s_1 - s_0 + \max(s_0, r_1)}\). As a result, the following hold true:
   \begin{align}
      p_0         &\geq r_0 \label{4.7}\\
      q_0         &\geq s_0 \label{4.8} \\
      p_0 - p_1   &\geq r_0 - r_1 \label{4.9} \\
      q_0 - q_1   &\geq s_0 - s_1 \label{4.10}
   \end{align}
   We want to show that \(p_0 - p_1 + \max(q_0, p_1) \geq r_0 - r_1 + \max(r_1, s_0)\). For this, we consider two cases: first the case where \(s_0 \geq r_1\), and second the case where \(s_0 < r_1\)
   Let \(s_0 \geq r_1\). We get the following chain of inequalities:
   \begin{align*}
      r_0 - r_1 + \max(s_0, r_1) &= r_0 - r_1 + s_0 \\
                                 &\stackrel{\ref{4.9}}{\leq}p_0 - p_1 + s_0\\
                                 &\stackrel{\ref{4.8}}{\leq}p_0 - p_1 + q_0\\
                                 &\stackrel{*}{\leq}p_0 - p_1 + \max(q_0, p_1)
   \end{align*}
   Where the inequality with \(*\) is justified, as \(\max(q_0, p_1) \geq q_0\) trivially holds. This concludes the first case.
   For the second case, we assume that \(s_0 < r_1\). 
   \begin{align*}
      r_0 - r_1 + \max(s_0, r_1) &= r_0 - r_1 + r_1 \\
                                 &= r_0 \\
                                 &\stackrel{\ref{4.7}}{\leq} p_0\\
                                 &\stackrel{*}{\leq} p_0 - p_1 + \max(q_0, p_1)
   \end{align*}
   Similarly, we justify \(*\), because \(\max(q_0, p_1) \geq p_1\), which means that \(-p_1 + \max(q_0, p_1) \geq 0\). 
\end{proof}
