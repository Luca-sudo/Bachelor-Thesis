\chapter{Introducing Lists}

Questions:
\begin{itemize}
   \item How to Propagate potential? E.g.: addL(addL(l)), where addL :: \(L(Int) \to L^5(Int)\)? Resulting type should be \(L^{10}(Int)\)?
   \item Same for resource pairs. Possible solution: Push cost to return type.
   \item How to best combine potential and resource pair in notation? 
\end{itemize}

In this chapter we introduce lists as a data type. As we will see, this necessitates various new definitions; The most salient being potentials. Previously, we attached resource-annotations to a type, which resulted in a "What-you-see-is-what-you-get" resource cost. For lists' we need to adapt, instead of a constant cost for any input list, we assign a cost to every list element. This results in resource-consumption respecting the variable length of lists. The notion of potentials will be a key concept in enabling this. Beyond lists, we introduce function application, which introduces recursion into our programming language. 

\begin{definition}[list-tick language]
   \label{def:prog-lang-6}

\begin{align*}
   e := ~~~ & \letexp{x}{e_1}{e_2}		& \text{(let)}\\
            & \tick{k}				& \text{(tick)}\\
	    & x					& \text{(var)}\\
	    & \true ~~| ~~\false		& \text{(bool constructors)}\\
	    & q					& \text{(const integer)}\\
            & \cons{x}{xs} ~~| ~~ \listnil      & \text{(list constructor)}\\
            & \listmatch{l}{e_1}{e_2}           & \text{(match list)}\\
            & f x                               & \text{(function application)}\\
\end{align*}
\end{definition}
\todo{Do I have to add function abstraction here?}

Because a list can contain \emph{any type} of data, assuming it is homogenous data, we introduce generic lists. Similarly, we need to introduce function types, which map values of one type to values of another type. For more concrete examples of list types and function types, we supplement examples below.

\begin{definition}[Type system]\label{def:type-system-6}
   \[
      A, B := \unit~|~\text{\bool}~|~\text{\typeint}~|~\ralist{}{A}~|~\rafunc{A}{B}{}{}
   \]
\end{definition}

\begin{example}
   \(\ralist{}{\typeint}\) is the type of lists that contain integers
\end{example}

\begin{example}
   \(\ralist{}{\ralist{}{\bool}}\) is the type of lists that contain lists with values of type \bool. A concrete example would be \([[1;2];[3;4];[5;6]]\).
\end{example}
\todo{Change notation}

\begin{example}
   A function \(\lambda x.x+1\) has the type \(\rafunc{\typeint}{\typeint}{}{}\).
\end{example}

\begin{example}
   A function \(\lambda l. \text{fold add  0  l}\), that sums integers in a list, has the type \(\rafunc{\ralist{}{\typeint}}{\typeint}{}{}\).
\end{example}



\section{Evaluation Semantics}

We start by introducing two rules for the construction of lists, corresponding to the two constructors of our programming language. In this thesis, construction of both empty and non-empty lists has no associated cost. As a result the cost of operations on lists is purely dictated by the actions performed on the list. 

\[
   \inference[(E:Nil)]
   {}
   {\evals{E}{\listnil}{null}{}{}}
   \qquad
   \inference[(E:Cons)]
   {\contains{E}{x, xs} \qquad l = (E(x), E(xs))}
   {\evals{E}{\cons{x}{xs}}{l}{}{}}
\]
\todo{Need to introduce null somewhere}

In order to implement functions that work recursively on a list, we need pattern matching on lists. Whenever a match statement involving a list is invoked, there are two cases: (1) The list passed to it is nil. (2) The list passed to it contains values. We define an evaluation rule for each of these cases, respectively:

\[
   \inference[(E:MatchNil)]
   {E(l) = Null \qquad \evals{E}{e_1}{v}{q_0}{q_1}}
   {\evals{E}{\listmatch{l}{e_1}{e_2}}{v}{q_0}{q_1}}
\]

\[
   \inference[(E:MatchCons)]
   {E(l) = (v_x, v_{xs}) \qquad \evals{\envaugment{E}{l}{(v_x, v_{xs})}}{e_2}{v}{q_0}{q_1}}
   {\evals{E}{\listmatch{l}{e_1}{e_2}}{v}{q_0}{q_1}}
\]

For the latter rule we define the concrete value of the list \(l\) as a tuple \((v_x, v_{xs})\). Where \(v_x\) points to the head, and \(v_{xs}\) points to the tail. 

To define recursive functions we are currently missing function application. With the evaluation rules provided until now, we are not able to derive a type for an expression of the form \(f x\). As a result, we would not be able to type a \emph{recursive} function call. 
In the rule below, \(e_f\) is the expression referenced by the function name \(f\). 

\[
   \inference[(E:App)]
   {E(f) = e_f \qquad \evals{\envaugment{E}{y}{x}}{e_f}{v}{q_0}{q_1}}
   {\evals{E}{f x}{v}{q_0}{q_1}}
\]
\todo{Need to define how we get from f to the expression of f}
\todo{Maybe talk about free and bound variables in preface?}

\section{Type Rules}

Our goal is to introduce type rules that allow us to assign resource costs to lists. Previously, we assigned a resource-pair (\cref{def:resource-pair}) to the resulting type; This is not feasible for lists, as the cost of evaluating an expression featuring a list depends on the length of the list. For this reason, we introduce the notion of \emph{potentials}. Intuitively, we assign a potential to a list, which corresponds to a cost for each list element. Having introduced potentials, we will define resource-aware lists, which forces us to consider how potentials can be composed and shared.

\subsection{Resource-Aware Lists}

We start by defining the type of resource-aware lists, the potential function, notation for the length of a list and deriving potential for lists with base types. For this, we start by defining resource-aware lists:

\begin{definition}[Resource-aware list]\label{def:ra-list}
   Let \(p \in \mathbb{N}\), and let \(A\) be a type from \cref{def:type-system-6}. A resource-aware list type is a pair comprising the \emph{base type} and \emph{potential}:

   \[
      \ralist{p}{A} = (\ralist{}{A}, p)
   \]
\end{definition}
\todo{Cref references definition as theorem}

In order to calculate resource bounds using the potential assigned to a list, we need to introduce a potential function. This will be the mathematical foundation for deriving resource bounds that respect the size of the list. 

\begin{definition}[Potential Function]\label{def:potential-function}
   For a value \(v\) of type \(A\), we define the potential of that value as follows:
   \[
      \Phi(v : A) \begin{cases}
         0                                            & A \in \{\unit, \typeint, \bool\}\\
         \Phi(x : B) + \Phi(xs : \ralist{q}{B}) + q   & A = \ralist{q}{B}
      \end{cases}
   \]
\end{definition}

\begin{definition}[Length of lists]\label{def:list-length}
   Given a list \(l : \ralist{}{A}\), we denote by \(|l|\) the \emph{length} of the list.
\end{definition}

The following corollary proves that, for lists that are not nested, the resulting potential of a list is \emph{only} dependent on the length of the list and the potential assigned to it.

\begin{corollary}[Potential of lists]\label{cor:potential-list}
   Let \(l : \ralist{q}{A}\), where \(A \in \{\unit, \typeint, \bool\}\). 
   \[
      \Phi(l : \ralist{q}{A}) = q \cdot |l|
   \]
\end{corollary}
\todo{Need to proof?}

Our definition of the potential function is even more flexible - we are able to derive a potential for \emph{nested lists}. This demonstrates that multivariate resource analysis is possible with our constructions.

\begin{corollary}[Potential of nested list]\label{cor:potential-nested-list}
   Let \(A \in \{\unit, \typeint, \bool\}\), and \(l_i\) be the lists nested inside \(l\). Then:
   \[
      \Phi(l : \ralist{p}{\ralist{q}{A}}) = |l| \cdot p + \sum_{l_i \in l} |l_i| \cdot q
   \]
\end{corollary}

Whenever we write programs, we might use a list in multiple instructions. In order to prevent inconsistencies with respect to the resulting potential, we introduce a sharing relation. Intuitively, this relation ensures that the overall potential of the list is precisely the sum of the potentials assigned to the occurrences.

\begin{definition}[Sharing Relation]
   Let \(A\) be a type from \cref{def:type-system-6}, and \(p, p_1, p_2 \in \mathbb{N}\).
   \begin{align*}
      A &\shares (A, A)                                           &\text{if } A \in \{\unit, \typeint, \bool\}\\
      \ralist{p}{A} &\shares (\ralist{p_1}{A}, \ralist{p_2}{A})   &\text{if } p = p_1 + p_2 
   \end{align*}
\end{definition}
\todo{Doesnt align correctly}
\todo{Notation for types? Something like \(A \in \mathbb{T}\)?}

\section{Inference Rules}

\begin{itemize}
   \item T:Nil
   \item T:Cons
   \item T:MatchList
      \begin{itemize}
         \item Explain why the constraints exist
      \end{itemize}
   \item T:App
      \begin{itemize}
         \item Mechanism to determine type of function? w.r.t resource-annotation?
      \end{itemize}
   \item T:Share
\end{itemize}

We start by introducing two rules associated to the two list constructors. 

\[
   \inference[(T:Nil)]
   {}
   {\typing{\Gamma}{nil}{\ralist{p}{A}}}
   \qquad
   \inference[(T:Cons)]
   {}
   {\typing{\Gamma;x : A; xs : \ralist{p}{A}}{cons(x, xs)}{\ralist{p}{A}}}
\]

In order to type expression that pattern match on lists, we introduce a rule (T:MatchList). 
\todo{Motivate the rule a bit}

\[
   \inference[(T:MatchList)]
   {\typing{\Gamma}{e_1}{\ratype{B}{q_0}{q_1}} \qquad \typing{\Gamma;x : A; xs : \ralist{p}{A}}{e_2}{\ratype{B}{q_0 + p}{q_1}}}
   {\typing{\Gamma;l : \ralist{p}{A}}{\listmatch{l}{e_1}{e_2}}{\ratype{B}{q_0}{q_1}}}
\]

Next, we introduce an inference rule for function application. For the rule to be valid, we must ensure that the value \(x\) applied to the function \(f\) has a type that matches the input of \(f\). Furthermore, the type of \(f x\) is then determined by the function \(f\). For resource-aware types, we compose the cost similar to a let expression. 

\[
   \inference[(T:Application)]
   {\typing{\Gamma}{f}{\rafunc{A}{B}{p_0}{p_1}} \qquad \typing{\Gamma}{x}{\ratype{A}{q_0}{q_1}}}
   {\typing{\Gamma}{f x}{\ratype{B}{r_0}{r_1}}}
   \qquad
   \begin{aligned}
      \text{where }  & r_0 = p_0 - p_1 + \max(p_1, q_0)\\
                     & r_1 = q_1 - q_0 + \max(p_1, q_0)
   \end{aligned}
\]

\todo{(T:Share) purposefully left out for now.}

To illustrate how the newly introduced inference rules orchestrate together, we perform exemplary type derivations for selected examples.

\subsection{Example Type Derivations}

We introduce examples of varying complexity, to illustrate the nuances of type derivation for functions and lists. 

\begin{example}
   For our first example, consider a function \(add1\) that increments every integer in a list.

\begin{minted}{ocaml}
   def add1 l = match l with 
      | nil -> nil
      | cons(x, xs) -> let _ = tick 2 in 
                       cons((x + 1), add1 xs)
\end{minted}

\newpage

The resulting type derivation is displayed in \cref{fig:type-derivation-add1}, let us briefly explain key parts of the derivation:

\begin{itemize}
   \item At the top, we labelled a premise using "Recursive Call", because we again apply the function \(add1\) to the tail (\(xs\)) of our initial list. We, therefore, can stop the derivation at this point without loss of information. We already collected the necessary constraints.

   \item In the second line, we typed the let expression with \(\ratype{\ralist{0}{\typeint}}{2}{0}\). This is the result of two facts: We did not collect any constraints that impose a potential on the resulting list. And, the inference rule for let expression requires us to consider the resource cost of the tick expression. 

   \item Lastly, we derive a potential of \(2\) for the input list \(l\). The expression that is evaluated for an empty list has no cost associated. For a non-empty list, we have an initial cost of 2. By definition of the (T:MatchList) rule, the potential \(p\) is precisely the difference in the two respective costs.
\end{itemize}

\begin{figure}[H]
\begin{center}
   \[
      \hspace*{-2.5cm}
      \inference
      {
         \typing{\Gamma}{\listnil}{\ralist{p}{A}} 
         &
         \inference
         {
            \typing{\Gamma}{\tick{2}}{\ratype{\unit}{2}{0}}
            &
            \inference
            {
               \inference
               {
                  \text{Recursive Call}
               }
               {
                  \typing{\Gamma;x:\typeint}{x + 1}{\typeint}
                  \typing{\Gamma;xs:\ralist{p}{\typeint}}{add1~xs}{\ralist{p}{\typeint}}
               }
            }
            {
               \typing{\Gamma;x:A;xs:\ralist{p}{A}}{\cons{x + 1}{add1~xs}}{\ralist{p}{\typeint}}
            }
         }
         {
            \typing{\Gamma;x:A;xs:\ralist{p}{A}}{\letexp{\_}{\tick{2}}{\cons{x+1}{add1~xs}}}{\ratype{\ralist{0}{\typeint}}{2}{0}}
         }
      }
      {
         \typing{\Gamma;l : \ralist{2}{\typeint}}{\listmatch{l}{\listnil}{\letexp{\_}{\tick{2}}{\cons{x+1}{add1~xs}}}}{\ralist{0}{\typeint}}
      }
   \]
   \end{center}
   \caption{Type derivation of the add1 function.}
   \label{fig:type-derivation-add1}
\end{figure}

The resulting resource-aware type for \(add1\) is, therefore:
\[
   add1 :: \rafunc{\ralist{2}{\typeint}}{\ralist{}{\typeint}}{}{}
\]
\end{example}

\begin{example}
   For our second example, we define a function \(sum\), which sums all the integers in a list, given an accumulator. 
   \begin{minted}{ocaml}
      def sum l n = match l with 
         | nil -> n
         | cons(x, xs) -> sum xs (n + x)
   \end{minted}
\end{example}

The associated type derivation can be found in \cref{fig:type-derivation-sum}. 

\begin{figure}[H]
\begin{center}
   \[
      \hspace*{-1.5cm}
      \inference
      {
         \typing{\Gamma}{\listnil}{\ralist{p}{A}}
         &
         \inference
         {
            \typing{}{\tick{3}{\ratype{\unit}{3}{0}}}
            &
            \inference
            {
               \text{Recursive Call}
            }
            {
               \typing
               {\Gamma;x:\typeint;xs:\ralist{p}{\typeint};n:\typeint}
               {sum~xs~(x+n)}
               {\typeint}
            }
         }
         {
            \typing
            {\Gamma;x:A;xs:\ralist{p}{A};n:B}
            {\letexp{\_}{\tick{3}}{sum~xs~(x+n)}}
            {\ratype{\typeint}{3}{0}}
         }
      }
      {
         \typing
         {\Gamma;l:\ralist{3}{\typeint};n:\typeint}
         {\listmatch{l}{\listnil}{\letexp{\_}{\tick{3}}{sum~xs~(x+n)}}}
         {\typeint}
      }
   \]
   \end{center}
   \caption{Type derivation of the sum function.}
   \label{fig:type-derivation-sum}
\end{figure}














\begin{itemize}
   \item Define function map
   \item Provide a type derivation
\end{itemize}

\begin{minted}{ocaml}
   def map f l = match l with 
      | nil -> nil
      | cons(x, xs) -> cons(f x, map f xs).
\end{minted}

\begin{itemize}
   \item Provide type derivation for map
   \item Example with nested lists?
      \begin{itemize}
         \item Need to define share for that?
      \end{itemize}
\end{itemize}

\section{Soundness}
\begin{itemize}
   \item Explain how introduction of potential alters soundness proof.
\end{itemize}

\section{Questions}

\begin{itemize}
   \item Suppose we have a function \emph{map}, with the signature \((A \to B) \to L(A) \to L(B)\). Where and how to attribute cost?
   \item Should we introduce the share rule? Would constraint us to a linear system?
\end{itemize}

