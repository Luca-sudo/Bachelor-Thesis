\chapter{Introducing Lists}
\begin{itemize}
   \item Short refresher on lists
   \item How cost for lists differ from current stuff
   \item What we introduce in this chapter
      \begin{itemize}
         \item Lists: constructor and matching
         \item Functions: abstraction and application
         \item Type signature refresher
         \item Potential function for cost of lists
      \end{itemize}
   \item Define the prog lang
\end{itemize}

In this chapter we introduce lists as a data type. As we will see, this necessitates various new definitions; The most salient being potentials. Previously, we attached resource-annotations to a type, which resulted in a "What-you-see-is-what-you-get" resource cost. For lists' we need to adapt, instead of a constant cost for any input list, we assign a cost to every list element. This results in resource-consumption respecting the variable length of lists. The notion of potentials will be a key concept in enabling this. Beyond lists, we introduce functions and a provide refresher on type signatures.

We introduce list construction and matching, as well as function application:


\begin{definition}[list-tick language]
   \label{def:prog-lang-6}

\begin{align*}
   e := ~~~ & \letexp{x}{e_1}{e_2}		& \text{(let)}\\
            & \tick{k}				& \text{(tick)}\\
	    & x					& \text{(var)}\\
	    & \true ~~| ~~\false		& \text{(bool constructors)}\\
	    & q					& \text{(const integer)}\\
            & \cons{x}{xs} ~~| ~~ \listnil      & \text{(list constructor)}\\
            & \listmatch{l}{e_1}{e_2}           & \text{(match list)}\\
            & f x                               & \text{(function application)}\\
\end{align*}
\end{definition}

For the reader not familiar with constructing lists using \cons{x}{xs}, we provide a small example to illustrate the use. Let us start by creating a list with integers from one to five. Conceptually, this list can be split up into the \emph{head}, one in this case, and its \emph{tail}, which is the sub list from two to five. Writing this out we get:
\[
   \cons{1}{\cons{2}{\cons{3}{\cons{4}{\cons{5}{\listnil}}}}}
\]

\section{Evaluation Semantics}

We start by introducing two rules for the construction of lists, corresponding to the two constructors of our programming language. In this thesis, construction of both empty and non-empty lists has no associated cost. As a result the cost of operations on lists is purely dictated by the actions performed on the list. 

\[
   \inference[(E:Nil)]
   {}
   {\evals{E}{\listnil}{null}{}{}}
   \qquad
   \inference[(E:Cons)]
   {\contains{E}{x, xs} \qquad l = (E(x), E(xs))}
   {\evals{E}{\cons{x}{xs}}{l}{}{}}
\]
\todo{Need to introduce null somewhere}

In order to implement functions that work recursively on a list, we need pattern matching on lists. Whenever a match statement involving a list is invoked, there are two cases: (1) The list passed to it is a null value. (2) The list passed to it contains values. We define an evaluation rule for each of these cases, respectively:

\[
   \inference[(E:MatchNil)]
   {E(l) = Null \qquad \evals{E}{e_1}{v}{q_0}{q_1}}
   {\evals{E}{\listmatch{l}{e_1}{e_2}}{v}{q_0}{q_1}}
\]

\[
   \inference[(E:MatchCons)]
   {E(l) = (v_x, v_{xs}) \qquad \evals{\envaugment{E}{l}{(v_x, v_{xs})}}{e_2}{v}{}{}}
   {\evals{E}{\listmatch{l}{e_1}{e_2}}{v}{q_0}{q_1}}
\]




\begin{itemize}
   \item E:Nil
   \item E:Cons
   \item E:MatchNil
   \item E:MatchCons
   \item E:App
      \begin{itemize}
         \item How do we reference function code properly?
      \end{itemize}
\end{itemize}

\section{Type Rules}
\begin{itemize}
   \item Introduce potential function
      \begin{itemize}
         \item Explain the role of potential
         \item explain why we only assign potential to lists
      \end{itemize}
   \item Define type system
   \item T:Nil
   \item T:Cons
   \item T:MatchList
      \begin{itemize}
         \item Explain why the constraints exist
      \end{itemize}
   \item T:App
      \begin{itemize}
         \item Mechanism to determine type of function? w.r.t resource-annotation?
      \end{itemize}
   \item T:Share???
\end{itemize}

\subsection{Example Type Derivation}
\begin{itemize}
   \item Define function map
   \item Provide a type derivation
\end{itemize}

\begin{minted}{ocaml}
   def map f l = match l with 
      | nil -> nil
      | cons(x, xs) -> cons(f x, map f xs).
\end{minted}

\begin{itemize}
   \item Provide type derivation for map
   \item Example with nested lists?
      \begin{itemize}
         \item Need to define share for that?
      \end{itemize}
\end{itemize}

\section{Soundness}
\begin{itemize}
   \item Explain how introduction of potential alters soundness proof.
\end{itemize}

\section{Questions}

\begin{itemize}
   \item Suppose we have a function \emph{map}, with the signature \((A \to B) \to L(A) \to L(B)\). Where and how to attribute cost?
   \item Should we introduce the share rule? Would constraint us to a linear system?
\end{itemize}

