\chapter{Adding Variables}

Before continuing, let us examine the limitations of the \nameref{def:prog-lang-4} from the previous chapter. We are not able to declare variables, control flow, or constants. All of those features will be implemented in this chapter. In order to declare and use variables in our programming language, we need to provide a definition of an environment, which comprises the concrete values of variables. As we will see, introducing variables will demand cautious reformulation of some evaluation rules to account for environments.

Similarly to environments, we will introduce contexts for the type rules. While an environment maps variables to concrete values, a context will map variables to types. This will also require carefully embellishing previous type rules, to provide rules that are rigorous with respect to contexts. We define the syntax of the augmented programming language below.

\begin{definition}[var-tick language]
   \label{def:prog-lang-5}

\begin{align*}
   e := ~~~ & \letexp{x}{e_1}{e_2}		& \text{(let)}\\
            & \tick{k}				& \text{(tick)}\\
	    & x					& \text{(var)}\\
	    & \true ~~| ~~\false		& \text{(bool constructors)}\\
	    & q					& \text{(const integers)}\\
\end{align*}
\end{definition}

The newly introduced constructors for integers and booleans are reflected in the type system for the language:

\begin{definition}[Type system]\label{def:type-system-5}
   \[
      \type := \unit~|~\text{\bool}~|~\text{\typeint}
   \]
\end{definition}

\section{Evaluation Semantics}

Expressions now feature variables, necessitating the introduction of \emph{environments} to resolve variables to their associated value. In \cref{sec:environments} we define environments, afterward we introduce evaluation rules in \cref{sec:evaluation-rules-var-tick}.

\subsection{Environments}\label{sec:environments}

Environments map variable names to values; For the variables that are not defined in the environment, the associated value is \textbf{undefined}. Here, \(\Var\) is the set of variable names, and \(\Vals\) is the set of values. 

\begin{definition}[Environment]\label{def:environment}
   We define an \textbf{environment} \(E: \text{\Var} \partialto \text{\Vals}\) as a partial function. Let \(x \in \Var\) and \(v_x \in \Vals\) be the value of \(x\).

   \[
      E(x) =
      \begin{cases}
	 v_x		    & \mbox{,if } E(x) \text{ is defined} \\
	 \textbf{undefined} &\mbox{,else}
      \end{cases}
   \]
\end{definition}

This definition facilitates existence checks for variables. If a variable \(x\) is defined in \(E\), then \(E(x) \neq \textbf{undefined}\); To assert that a variable is defined, we simply write \(x \in E\).

In most programming settings, we start with an empty environment and incrementally populate it with variables as our program evaluates. This constitutes the need for extending environments - we want to add variables to the environment upon introducing them.

\begin{definition}\label{def:environment-augment}	
   Let \(E\) be an \nameref{def:environment}, \(a\) be a variable name and \(v_a\) be the value assigned to \(a\). We write \(E[a \mapsto v_a]\) for the environment \(E\), where \(a\) is additionally mapped onto \(v_a\):

   \[
      \envaugment{E}{a}{v_a} = 
      \begin{cases}
	 E(x)  & \mbox{,if } x \neq a\\
	 v     & \mbox{,else } 
      \end{cases}
   \]

\end{definition}

Having all of these definitions in place, we now update the definition of an \emph{evaluation judgement}. Previously, expression were evaluated as is, as no environment influenced the execution of the expression. Now, we consider evaluating expression against an environment \(E\).

\begin{definition}[Evaluation Judgement with Environments]\label{def:eval-judgement-environments}
   Let \(E\) be an \nameref{def:environment}, \(e\) an expression of our programming language (\cref{def:prog-lang-5}), \(v\) the value obtained from evaluating \(e\), and let \((p_0, p_1) \in \resource\). We then write the following for the evaluation judgement with respect to an environment:

   \[
      \evals{E}{e}{v}{p_0}{p_1}
   \]
	
\end{definition}

\begin{remark}
   Note that the evaluation of an expression \(e\) depends on the environment, due to the ambiguity of variable names. Thus, both the return value \(v\) and the resource demand \((p_0, p_1)\) can differ for disparate environments. 
\end{remark}

\subsection{Evaluation Rules}\label{sec:evaluation-rules-var-tick}

Having all the necessary definitions at hand, let us now define evaluation rules for our programming language. We start with the rule (E:var), which provides an explicit handle for resolving variable names to their values. In order for the rule to be consistent, we must enforce that the variable we want to resolve is defined in the current environment. 

\[
   \inference[(E:var)]
   {\contains{E}{x}}
   {\evals{E}{x}{E(x)}{}{}}
\]

Next, we define one rule (E:bool) that unifies the evaluation of both boolean constants. Similarly, we define the evaluation of constant integers using the rule (E:Int). In contrast to the previous rule, we do not need to check the environment for existence of any variables, as both booleans and integers are evaluated in a direct manner.

\[
   \inference[(E:bool)]{b \in \{\true, \false\}}{\evals{E}{b}{b}{}{}}%
   \quad\quad\quad
   \inference[(E:int)]{n \in \mathbb{Z}}{\evals{E}{n}{n}{}{}}
\]

Next, we introduce the evaluation rule for \textbf{tick}. Here, the concrete environment has no impact on the evaluation of a tick expression, it is evaluated \emph{as is}. 

\[
   \inference[(E:tick)]
   {}
   {\evals{E}{\tick{q}}{()}{r_0}{r_1}}%
   \qquad 
   \begin{aligned}
      \text{where }  &r_0 = \max(q, 0)\\
      \text{and }    &r_1 = \max(0, -q) 
   \end{aligned}
\]

Given an expression \(\tick{k}\), there are two mutually exclusive cases: \(k\) is positive, or it is negative. In the former case, \(r_0\) reduces to \(k\) and \(r_1\) to zero. In the latter case, \(r_0\) is zero and \(r_1\) reduces to \(|q|\), which is again a positive number - as desired. 

The last rule missing is (E:let). Here, we need to carefully weave the value that is the result of the first expression into the second expression. We do so by augmenting the environment using the variable name and result of the preceding sub-expression.

\[
   \inference[(E:let)]
   {\evals{E}{e_1}{v_1}{p_0}{p_1} \qquad \evals{\envaugment{E}{x}{v_1}}{e_2}{v_2}{q_0}{q_1}}
   {\evals{E}{\letexp{x}{e_1}{e_2}}{v_2}{r_0}{r_1}}%
\]
\begin{align*}
   \text{where }  &(r_0, r_1) = (p_0, p_1) \sequence (q_0, q_1)
\end{align*}


\section{Type Rules}\label{sec:type-rules-5}

To type expressions with variables, knowledge of a variable's type is paramount. This necessitates the definition of \emph{contexts} (\cref{def:context}), along with ergonomic notations. The introduction of contexts requires extending \emph{typing judgements} (\cref{def:type-judgement-context}). With these in place, we define the \emph{inference rules} (\cref{sec:inference-rules-letvar}) that are context-aware.

\subsection{Contexts}

What environments are for evaluation rules, contexts are for inference rules. Contexts allow us to map variables to types, which is necessary since introducing variables. Similar to \nameref{def:environment}s, a context is a partial function; Conversely to environments, a context maps variable names to a type from \cref{def:type-system-5}:

\begin{definition}[Context]\label{def:context}
   We define a \emph{context} \(\Gamma : \text{\Var} \partialto \text{\type}\) as a partial function from variable names to types. Let \(x\) be a variable and \(A \in \type\).

   \[
      \Gamma(x) = 
      \begin{cases}
	 A		      & \mbox{,if } \Gamma(x) \text{ is defined}\\
	 \textbf{undefined}   & \mbox{,else } 
      \end{cases}
   \]
\end{definition}

Inference rules may enforce that a variable \(x\) is defined in a context \(\Gamma\). Intuitively, a variable is defined inside a context if \(\Gamma(x) \neq \textbf{undefined}\). We write \(x \in \Gamma\) to denote that \(x\) is defined in \(\Gamma\).

At the start of executing a program the context is empty. During execution, variables are initialized; This requires extending the context to account for the newly initialized variable. Given that \(x : A\) we add \(x\) to \(\Gamma\) by writing \(\Gamma; x : A\).

Some use cases require us to consider every variable defined in a context \(\Gamma\). For example, in \cref{def:context-potential} we sum over every variable in the context. We introduce a contexts' \emph{domain} as the set of variables that are defined in that context.

\begin{definition}[Domain of Context]\label{def:context-domain}
   Given a context \(\Gamma\), the \emph{domain} is the set of all variables that are defined in \(\Gamma\).
   
   \[
      \domain{\Gamma} = \{x \in \Var ~|~ \Gamma(x) \neq \textbf{undefined}\} 
   \]
\end{definition}

While executing a program, multiple variables with the name \(x\) may be created at discrete times. It is important to note that the \emph{most recent} initialization will determine the value of \(\Gamma(x)\) - for let expressions, this can lead to inconsistencies. \emph{Disjoint} contexts circumvent this problem, as two disjoint contexts do not share any variables, eliminating the chance for inconsistencies.

\begin{definition}[Disjoint contexts]\label{def:disjoint-contexts}
   Let \(\Gamma_1, \Gamma_2\) be contexts. 

   \[
      \Gamma_1 \text{ and } \Gamma_2 \text{ are disjoint} :\iff \domain{\Gamma_1} \cap \domain{\Gamma_2} = \emptyset
   \]
\end{definition}

With contexts defined, we embed them into our new definition of a \emph{typing judgement}.

\begin{definition}[Typing Judgement with contexts]\label{def:type-judgement-context}
   Let \(\Gamma\) be a \nameref{def:context}, \(e\) an expression of \cref{def:prog-lang-5} with the return type \(A\), and let \((p_0, p_1) \in \resource\). We then denote a typing judgement with respect to the context \(\Gamma\) by writing:
   \[
      \typing{\Gamma}{e}{\ratype{A}{p_0}{p_1}}
   \]
\end{definition}

\begin{remark}
   Similarly to \cref{def:eval-judgement-environments}, the resource-aware type assigned to \(e\) will vary on the context in which \(e\) is evaluated. 
\end{remark}

\subsection{Inference Rules}\label{sec:inference-rules-letvar}

Let us start by introducing the rule (T:var), which allows us to add a variable and its associated type into a context.

\[
   \inference[(T:var)]
   {}
   {\typing{\Gamma; x: A}{x}{A}}
\]

Next, we introduce two rules, one for boolean constants and one for integer constants. The rule (T:bool) assigns a type \bool~to any occurrence of \(\true\) or \(\false\), and similarly, the rule (T:int) assigns a type \typeint~to any occurrence of integer constants.

\[
   \inference[(T:bool)]
   {b \in \{\true, \false\}}
   {\typing{\Gamma}{b}{\text{\bool}}}%
   \qquad
   \inference[(T:int)]
   {n \in \mathbb{Z}}
   {\typing{\Gamma}{n}{\text{\typeint}}}
\]

Defining the type rule for the \(\tick{}\) is straightforward, we add a context \(\Gamma\) to the rule from the previous chapter \cref{def:tr-tick-4}:

\[
   \inference[(T:tick)]
   {q_0 \geq k + q_1}
   {\typing{\Gamma}{\tick{k}}{\ratype{\unit}{q_0}{q_1}}}
\]

\begin{remark}
   As the sub-expressions of the let expression might have different contexts, we need to account for that as well. To permit a consistent formulation of the type rule, we need to add an assumption: the two contexts need to be \emph{disjoint}. This will allow us to avoid any typing inconsistencies that could arise from mismatched types between the two contexts. 
   For this, a variable \(x\) could be present in both contexts \(\Gamma_1\) and \(\Gamma_2\), with different types assigned to the variable:

   \[
      \typing{\Gamma_1}{x}{A} \qquad \typing{\Gamma_2}{x}{B}
   \]

   This is prevented, by demanding that the contexts are \emph{disjoint}. While this makes the rule less flexible, we avoid cases where the application of (T:let) would yield a possibly ill-typed judgement; If the variable \(x\) is present in both contexts, altering the type of that variable may construe the resulting typing of the expression.
\end{remark}

This leads to the following formulation of the rule (T:Let), that uses \emph{disjoint} contexts.

\[
   \inference[(T:let)]
   {\typing{\Gamma_1}{e_1}{\ratype{A}{p_0}{m}} \qquad \typing{\Gamma_2}{e_2}{\ratype{B}{m}{q_1}} \qquad \Gamma_1 \cap \Gamma_2 = \emptyset}
   {\typing{\Gamma_1; \Gamma_2}{\letexp{x}{e_1}{e_2}}{\ratype{B}{p_0}{q_1}}}
\]

It is important to note that (T:let) requires the residual resources from the first expression to match the initial resources of the second expression - the rule is stringent compared to its predecessor from the previous chapter. Now, there exist pairs of resource demands that cannot be typed; We circumvent this restriction by introducing a rule (T:relax) that allows us to type an expression with any other resource demand that is a \emph{relaxation} of the original resource demand. This allows us to match residual and initial resources to be the same, facilitating application of (T:let).

\[
   \inference[(T:relax)]
   {\typing{\Gamma}{e}{\ratype{A}{p_0}{p_1}} \qquad (q_0, q_1) \relaxation (p_0, p_1)}
   {\typing{\Gamma}{e}{\ratype{A}{q_0}{q_1}}}
\]

\begin{example}
   Given \(\typing{\Gamma}{e_1}{\ratype{A}{1}{0}}\) and \(\typing{\Gamma}{e_2}{\ratype{A}{2}{3}}\), application of (T:let) is not permitted. The first expression is required to have \(2\) residual resources; Relaxation of \((1, 0)\) to \((3, 2)\) permits application of (T:let).
\end{example}


\section{Soundness}

Having introduced \nameref{def:environment}s and \nameref{def:context}s, it is necessary to formulate the soundness theorem as to account for environments and contexts. This yields the following statement:

\begin{theorem}[Soundness of typing for var-tick language]\label{thm:soundness-5}
   Let \(E\) be an \nameref{def:environment}, \(\Gamma\) be a \nameref{def:context}. Further, let \(A\) be a type, \((p_0, p_1), (q_0, q_1) \in \resource\) and an expression \(e\) that evaluates to the value \(v\). The Soundness Theorem states:

   \begin{center}
   If \(\evals{E}{e}{v}{p_0}{p_1}\) and \(\typing{\Gamma}{e}{\ratype{A}{q_0}{q_1}}\), then \(v : \ratype{A}{}{}\) with \((q_0, q_1) \relaxation (p_0, p_1)\).
   \end{center}
\end{theorem}

\begin{proof}

(tick): The proof given in \cref{thm:soundness-let-tick} for the tick expression still holds.

(bool): We know that \(p_0 = p_1 = 0 = q_0 = q_1\) by definition. As a result \(p_0 \geq q_0\) and \(p_0 - p_1 \geq q_0 - q_1\), which is identical to \((p_0, p_1) \relaxation (q_0, q_1)\). It furthermore follows that the type of the resulting value \(b\) is of type \bool~, and such, consistent with the typing derived from the type rule.

(int): Identical to the previous proof, we get that \(p_0 = p_1 = 0 = q_0 = q_1\) which shows \((p_0, p_1) \relaxation (q_0, q_1)\), and similarly, the type of \(n\) is \typeint~, which is consistent.

(let): We have a program of the form \(\letexp{x}{e_1}{e_2}\). Here, the let expression is a special case. Where any other language construct corresponded to exactly one type rule, the let expression may be typed by two different rules, (T:let) or (T:relax). As such, we need to prove that for the application of both type rules, soundness holds.  

For (T:let): The proof from \cref{thm:soundness-let-tick} still holds.

For (T:relax): What is special for the (T:relax) inference rule is that it could be applied an arbitrary (finite!) number of times. Thus our prove changes slightly. Instead of proving soundness for one application of (T:Relax), we use induction. 

Let us start with the base case; That is, applying (T:Relax) \emph{once}. By assumption, the following to hold true: \(\evals{E}{\letexp{x}{e_1}{e_2}}{v}{r_0}{r_1}\) and \(\typing{\Gamma}{\letexp{x}{e_1}{e_2}}{\ratype{A}{p_0}{p_1}}\) and (\((p_0, p_1) \relaxation (r_0, r_1)\). As \((p_0, p_1) \relaxation (r_0, r_1)\) is exactly what we wanted to show, we are done for the base case.

For the induction step, we can leverage the fact that the relaxation relation defines a partial ordering, or more specifically, is \emph{transitive}. Our induction hypothesis includes the following assumptions:

   \begin{align*}
      &										    & &\exists (m_0, m_1) \in \resource\\
      &\typing{\Gamma}{\letexp{x}{e_1}{e_2}}{\ratype{\unit}{p_0}{p_1}}                   & &(p_0, p_1)\relaxation (m_0, m_1)\\
      &\evals{E}{\letexp{x}{e_1}{e_2}}{v_1}{q_0}{q_1}                               & &(m_0, m_1)\relaxation (q_0, q_1)\\
   \end{align*}

Where \((r_0, r_1)\) is the resource-annotation of the previous application of (T:Relax). As the relaxation relation is transitive, it follows that \((p_0, p_1) \relaxation (q_0, q_1)\). Which concludes our proof.

\end{proof}





