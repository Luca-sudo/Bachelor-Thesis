\chapter{Adding Variables}

Before continuing, let us examine the limitations of the \nameref{def:prog-lang-4} from the previous chapter. We are not able to declare variables, control flow, or constants. All of those features will be implemented in this chapter. In order to declare and use variables in our programming language, we need to provide a definition of an environment, which comprises the concrete values of variables. As we will see, introducing variables will demand cautious reformulation of some evaluation rules to account for environments.

Similarly to environments, we will introduce contexts for the type rules. While an environment maps variables to concrete values, a context will map variables to types. This will also require carefully embellishing previous type rules, to provide rules that are rigorous with respect to contexts. We define the syntax of the augmented programming language below.

\begin{definition}[var-tick language]
   \label{def:prog-lang-5}

\begin{align*}
   e := ~~~ & \letexp{x}{e_1}{e_2}		& \text{(let)}\\
            & \tick{k}				& \text{(tick)}\\
	    & x					& \text{(var)}\\
	    & \true ~~| ~~\false		& \text{(bool constructors)}\\
	    & q					& \text{(const integers)}\\
\end{align*}
\end{definition}

The newly introduced constructors for integers and booleans are reflected in the type system for the language:

\begin{definition}[Type system]\label{def:type-system-5}
   \[
      \type := \unit~|~\text{\bool}~|~\text{\typeint}
   \]
\end{definition}

\section{Evaluation Semantics}

We begin this section by introducing environments, which provide a necessary link between variable names and values. For this, we define an \nameref{def:environment}, which is a mapping from variable names to values. Along with this, we introduce two notations related to environments, one for retrieving the value of the variable and another notation that allows us to check if an environment contains a specific variable name; This will be needed to ensure that rules featuring variables are correctly defined.

\subsection{Environments}\label{sec:environments}

\begin{definition}[Environment]\label{def:environment}
   We define an \textbf{environment} \(E: \text{\Var} \partialto \text{\Vals}\) as a partial function from variable names (\Var) to values (\Vals). 
\end{definition}

Whenever we have a variable name, we want to get the concrete value associated with that variable. As we defined an environment as a \emph{partial function}, we can simply apply the variable name of interest to the environment.

\begin{definition}\label{def:environment-getter}	
   Let \(E\) be an \nameref{def:environment} and \(x\) be a variable name, we then write \(E(x)\) for the value of \(x\) in the environment \(E\):
   \[
      E(x) =
      \begin{cases}
	 v_x		    & \mbox{,if } E(x) \text{ is defined} \\
	 \textbf{undefined} &\mbox{,else}
      \end{cases}
   \]
\end{definition}

With this definition, it is easy to check an environment for the existance of a variable. If applying the environment to the variable returns \textbf{undefined} then the variable is not defined. Conversely, we know that a variable is defined, should the environment return a value.

\begin{definition}\label{def:in-environment}
   Given an \nameref{def:environment} \(E\) and a variable name \(x\), we define \(\contains{E}{x}\) as follows:
   \[
      \contains{E}{x} = 
      \begin{cases*}
	 \false & \mbox{,if E(x) is } \textbf{undefined}\\
	 \true & \mbox{,else} 
      \end{cases*}
   \]
\end{definition}

In most programming settings, we start with an empty environment and incrementally populate it with variables as our program evaluates. This constitutes the need for extending environments - we want to add variables to the environment upon introducing them.

\begin{definition}\label{def:environment-augment}	
   Let \(E\) be an \nameref{def:environment}, \(a\) be a variable name and \(v\) be the value assigned to \(a\). We write \(E[a \mapsto v]\) for the environment \(E\), where \(a\) is additionally mapped onto \(v\):

   \[
      \envaugment{E}{a}{v} = 
      \begin{cases}
	 E(x)  & \mbox{,if } x \neq a\\
	 v     & \mbox{,else } 
      \end{cases}
   \]

\end{definition}

Having all of these definitions in place, we can now update the definition of an \emph{evaluation judgement}. Previously, we did not have variables in any expression. As a result, the expressions were evaluated as is, irrespective of an environment, as there was no state to keep track of. As we now evaluate expressions with respect to \nameref{def:environment}s, we need to update \cref{def:evaluation-judgement} to use environments:
\todo{cref ref definition as theorem}

\begin{definition}[Evaluation Judgement with Environments]\label{def:eval-judgement-environments}
   Let \(E\) be an \nameref{def:environment}, \(e\) an expression of our programming language (\cref{def:prog-lang-5}), \(v\) the value obtained from evaluating \(e\), and let \((p_0, p_1) \in \resource\). We then write the following for the evaluation judgement with respect to an environment:

   \[
      \evals{E}{e}{v}{p_0}{p_1}
   \]
	
\end{definition}

\subsection{Evaluation Rules}

Having all the necessary definitions at hand, let us now define evaluation rules for our programming language. We start with the rule (E:var), which provides an explicit handle for resolving variable names to their values. In order for the rule to be consistent, we must enforce that the variable we want to resolve is defined in the current environment. 

\[
   \inference[(E:var)]
   {\contains{E}{x}}
   {\evals{E}{x}{E(x)}{}{}}
\]

Next, we define one rule (E:bool) that unifies the evaluation of both boolean constants. Similarly, we define the evaluation of constant integers using the rule (E:Int). In contrast to the previous rule, we do not need to check the environment for existence of any variables, as both booleans and integers are evaluated in a direct manner.

\[
   \inference[(E:bool)]{b \in \{\true, \false\}}{\evals{E}{b}{b}{}{}}%
   \quad\quad\quad
   \inference[(E:int)]{n \in \mathbb{Z}}{\evals{E}{n}{n}{}{}}
\]

Next, we introduce the evaluation rule for \textbf{tick}. Here, the concrete environment has no impact on the evaluation of a tick expression, it is evaluated \emph{as is}. 

\[
   \inference[(E:tick)]
   {}
   {\evals{E}{\tick{q}}{()}{r_0}{r_1}}%
   \qquad 
   \begin{aligned}
      \text{where }  &r_0 = \max(q, 0)\\
      \text{and }    &r_1 = \max(0, -q) 
   \end{aligned}
\]

Given an expression \(\tick{k}\), there are two mutually exclusive cases: \(k\) is positive, or it is negative. In the former case, \(r_0\) reduces to \(k\) and \(r_1\) to zero. In the latter case, \(r_0\) is zero and \(r_1\) reduces to \(|q|\), which is again a positive number - as desired. 

The last rule missing is (E:let). Here, we need to carefully weave the value that is the result of the first expression into the second expression. We do so by augmenting the environment using the variable name and result of the preceding sub-expression.

\[
   \inference[(E:let)]
   {\evals{E}{e_1}{v_1}{p_0}{p_1} \qquad \evals{\envaugment{E}{x}{v_1}}{e_2}{v_2}{q_0}{q_1}}
   {\evals{E}{\letexp{x}{e_1}{e_2}}{v_2}{r_0}{r_1}}%
   \qquad
   \begin{aligned}
      \text{where }  &r_0 = p_0 - p_1 + \max(p_1, q_0)\\
      \text{and }    &r_1 = q_1 - q_0 + \max(p_1, q_0) 
   \end{aligned}
\]


\section{Type Rules}\label{sec:type-rules-5}

In the previous chapter, the programming language at hand only produced values of a singular type \textbf{unit}. For this programming language, we introduced two new types which forces us to reconsider the type we assign to \emph{sequential expressions}. For this, we note two facts: (1) The resource-consumption assigned to a sequential operation is invariant of the type the operation returns. (2) The result of the first expression is consumed by the second expression, and, therefore, the result of the sequential evaluation is defined by the return type of the second expression. This motivates the following, updated definition:

\begin{definition}
   Let \(e_1 : \ratype{A}{p_0}{p_1}\) and \(e_2 : \ratype{B}{q_0}{q_1}\) be two expressions, where \(A\) and \(B\) are types from \cref{def:type-system-5}. Sequential evaluation of \(e_1, e_2\) then yields the type:
   \[
      \letexp{x}{e_1}{e_2} : \ratype{B}{r_0}{r_1}
      \qquad
      \begin{aligned}
	 \text{where }	&r_0 = p_0 - p_1 + \max(p_1, q_0) \\
			&r_1 = q_1 - q_0 + \max(p_1, q_0)
      \end{aligned}
   \]
\end{definition}

\subsection{Contexts}

What environments are for evaluation rules, contexts are for inference rules. Contexts allow us to map variables to types, which is necessary since introducing variables. Similar to \nameref{def:environment}s, a context is a partial function that assigns to variable names a type from \cref{def:type-system-5}:

\begin{definition}[Context]\label{def:context}
   We define a \emph{context} \(\Gamma : \text{\Var} \partialto \text{\type}\) as a partial function from variable names to types.
\end{definition}

Similarly to \cref{sec:environments}, we define how to retrieve the type of a variable, given a context, what it means for a variable to be in a context and how we can introduce new variables into a context. 

\begin{definition}\label{def:context-getter}
   Let \(\Gamma\) be a \emph{context}, \(x\) be a variable name and \(A \in \mathbb{T}\) the type of \(x\). 

   \[
      \Gamma(x) = 
      \begin{cases}
	 A		      & \mbox{,if } \Gamma(x) \text{ is defined}\\
	 \textbf{undefined}   & \mbox{,else } 
      \end{cases}
   \]

\end{definition}

\begin{definition}\label{def:in-context}
   Let \(\Gamma\) be a \emph{context} and \(x\) be a variable name, we define \(\contains{\Gamma}{x}\) as follows:
   \[
      x \in \Gamma =
      \begin{cases}
	 \false	     & \text{,if } \Gamma(x) \text{ is undefined}\\
	 \true	     & \text{,else}
      \end{cases}
   \]
\end{definition}

\begin{definition}\label{def:context-augment}
   Let \(\Gamma\) be a context, \(A\) be a type and let \(x : A\) be a variable. We can embed the variable \(x\) with its associated type \(A\) into the context \(\Gamma\),  by writing \(\Gamma ; x:A\).
\end{definition}

In order to define a type rule for let expressions, we need to define when two contexts are \emph{disjoint}. Intuitively, they are disjoint, if any variable is not in both contexts. 

\begin{definition}[Disjoint contexts]
   Let \(\Gamma_1, \Gamma_2\) be contexts. Then, \(\Gamma_1 \cap \Gamma_2 = \emptyset\), if and only if for any variable x it holds that \(\neg(x \in \Gamma_1 \wedge x \in \Gamma_2)\).
\end{definition}

\begin{definition}[Typing Judgement with contexts]\label{def:type-judgement-context}
   Let \(\Gamma\) be a \nameref{def:context}, \(e\) an expression of \cref{def:prog-lang-5} with the return type \(A\), and let \((p_0, p_1) \in \resource\). We then denote a typing judgement with respect to the context \(\Gamma\) by writing:
   \[
      \typing{\Gamma}{e}{\ratype{A}{p_0}{p_1}}
   \]
\end{definition}

\subsection{Inference Rules}

Let us start by introducing the rule (T:var), which allows us to add a variable and its associated type into a context.

\[
   \inference[(T:var)]
   {}
   {\typing{\Gamma; x: A}{x}{A}}
\]

Next, we introduce two rules, one for boolean constants and one for integer constants. The rule (T:bool) assigns a type \bool~to any occurrence of \(\true\) or \(\false\), and, similarly, the rule (T:int) assigns a type \typeint to any occurrence of integer constants.

\[
   \inference[(T:bool)]
   {b \in \{\true, \false\}}
   {\typing{\Gamma}{b}{\text{\bool}}}%
   \qquad
   \inference[(T:int)]
   {n \in \mathbb{Z}}
   {\typing{\Gamma}{n}{\text{\typeint}}}
\]

Defining the type rule for the \(\tick{}\) is straightforward, we add a context \(\Gamma\) to the rule from the previous chapter \cref{def:tr-tick-4}:

\[
   \inference[(T:tick)]
   {q_0 \geq k + q_1}
   {\typing{\Gamma}{\tick{k}}{\ratype{\unit}{q_0}{q_1}}}
\]

As the sub-expressions of the let expression might have different contexts, we need to account for that as well. To permit a consistent formulation of the type rule, we need to add an assumption: the two contexts need to be \emph{disjoint}. This will allow us to avoid any typing inconsistencies that could arise from mismatched types between the two contexts. 
For this, a variable \(x\) could be present in both contexts \(\Gamma_1\) and \(\Gamma_2\), with differnt types assigned to the variable:

\[
   \typing{\Gamma_1}{x}{A} \qquad \typing{\Gamma_2}{x}{B}
\]

This is prevented, by demanding that the contexts are \emph{disjoint}. While this makes the rule less flexible, we avoid cases where the application of (T:let) would yield a possibly ill-typed judgement; If the variable \(x\) is present in both contexts, altering the type of that variable may construe the resulting typing of the expression.

\[
   \inference[(T:let)]
   {\typing{\Gamma_1}{e_1}{\ratype{A}{p_0}{m}} \qquad \typing{\Gamma_2}{e_2}{\ratype{B}{m}{q_1}} \qquad \Gamma_1 \cap \Gamma_2 = \emptyset}
   {\typing{\Gamma_1; \Gamma_2}{\letexp{x}{e_1}{e_2}}{\ratype{B}{p_0}{q_1}}}
\]

Compared to the previous chapter, we made the rule (T:let) stricter, by requiring that the \nameref{def:resource-disparity} between the two expressions is zero. As this would deny typing for \(\tick{}\) expressions that have a non-zero resource-disparity, we introduce another rule (T:relax) that allows us to \emph{relax} the resource-annotations into ones that permit applying (T:let) - only if that is possible. 
We need to administer special caution when defining the relax rule, as we \emph{do not} want to reduce the resource demand. We do this, by enforcing that \((q_0, q_1) \relaxation (p_0, p_1)\).

\[
   \inference[(T:relax)]
   {\typing{\Gamma}{e}{\ratype{A}{p_0}{p_1}} \qquad (q_0, q_1) \relaxation (p_0, p_1)}
   {\typing{\Gamma}{e}{\ratype{A}{q_0}{q_1}}}
\]



\section{Soundness}

Having introduced \nameref{def:environment}s and \nameref{def:context}s, it is necessary to formulate the soundness theorem as to account for environments and contexts. This yields the following statement:

\begin{theorem}[Soundness of typing for var-tick language]\label{thm:soundness-5}
   Let \(E\) be an \nameref{def:environment}, \(\Gamma\) be a \nameref{def:context}. Further, let \(A\) be a type, \((p_0, p_1), (q_0, q_1) \in \resource\) and an expression \(e\) that evaluates to the value \(v\). The Soundness Theorem states:

   \begin{center}
   If \(\evals{E}{e}{v}{p_0}{p_1}\) and \(\typing{\Gamma}{e}{\ratype{A}{q_0}{q_1}}\), then \(v : \ratype{A}{}{}\) with \((q_0, q_1) \relaxation (p_0, p_1)\).
   \end{center}
\end{theorem}

\begin{proof}

(tick): The proof given in \cref{thm:soundness-4} for the tick expression still holds.

(bool): We know that \(p_0 = p_1 = 0 = q_0 = q_1\) by definition. As a result \(p_0 \geq q_0\) and \(p_0 - p_1 \geq q_0 - q_1\), which is identical to \((p_0, p_1) \relaxation (q_0, q_1)\). It furthermore follows that the type of the resulting value \(b\) is of type \bool~, and such, consistent with the typing derived from the type rule.

(int): Identical to the previous proof, we get that \(p_0 = p_1 = 0 = q_0 = q_1\) which shows \((p_0, p_1) \relaxation (q_0, q_1)\), and similarly, the type of \(n\) is \typeint~, which is consistent.

(let): We have a program of the form \(\letexp{x}{e_1}{e_2}\). Here, the let expression is a special case. Where any other language construct corresponded to exactly one type rule, the let expression may be typed by two different rules, (T:let) or (T:relax). As such, we need to prove that for the application of both type rules, soundness holds.  

For (T:let): The proof from \cref{let-tick:soundness-t-let} still holds.

For (T:relax): What is special for the (T:relax) inference rule is that it could be applied an arbitrary (finite!) number of times. Thus our prove changes slightly. Instead of proving soundness for one application of (T:Relax), we use induction. 

Let us start with the base case; That is, applying (T:Relax) \emph{once}. By assumption, the following to hold true: \(\evals{E}{\letexp{x}{e_1}{e_2}}{v}{r_0}{r_1}\) and \(\typing{\Gamma}{\letexp{x}{e_1}{e_2}}{\ratype{A}{p_0}{p_1}}\) and (\((p_0, p_1) \relaxation (r_0, r_1)\). As \((p_0, p_1) \relaxation (r_0, r_1)\) is exactly what we wanted to show, we are done for the base case.

For the induction step, we can leverage the fact that the relaxation relation defines a partial ordering, or more specifically, is \emph{transitive}. Our induction hypothesis includes the following assumptions:

   \begin{align*}
      &										    & &\exists (m_0, m_1) \in \resource\\
      &\typing{\Gamma}{\letexp{x}{e_1}{e_2}}{\ratype{\unit}{p_0}{p_1}}                   & &(p_0, p_1)\relaxation (m_0, m_1)\\
      &\evals{E}{\letexp{x}{e_1}{e_2}}{v_1}{q_0}{q_1}                               & &(m_0, m_1)\relaxation (q_0, q_1)\\
   \end{align*}

Where \((r_0, r_1)\) is the resource-annotation of the previous application of (T:Relax). As the relaxation relation is transitive, it follows that \((p_0, p_1) \relaxation (q_0, q_1)\). Which concludes our proof.

\end{proof}





